
#Область ЗапускОбработчиков

//Процедура - Запустить обработчкики 
//
Процедура ЗапуститьОбработчики() Экспорт
	
	Если Не сшпФункциональныеОпции.ИспользоватьСШП() Тогда 
		
		Возврат;
		
	КонецЕсли;
	
	ИмяСобытияЖР = "Datareon.Инициация подключения к адаптеру";
	
	ЗаписьЖурналаРегистрации(ИмяСобытияЖР, УровеньЖурналаРегистрации.Информация, , , ИмяСобытияЖР);
	
	Если Не сшпОбщегоНазначения.ПроверитьЭкземплярИнформационнойБазы() Тогда
		
		ЗаписьЖурналаРегистрации(ИмяСобытияЖР, УровеньЖурналаРегистрации.Ошибка, , , "Рассинхронизация идентификаторов информационной базы");
		
		Возврат;
		
	КонецЕсли;
	
	ДанныеСтрокиСоединения = сшпРаботаСоСтроками._СтрРазделить(СтрокаСоединенияИнформационнойБазы(), ";");
	
	Если Не ДанныеСтрокиСоединения.Количество() = 3 Тогда
		
		ЗаписьЖурналаРегистрации(ИмяСобытияЖР, УровеньЖурналаРегистрации.Ошибка, , ,"Работа с файловыми информационными базами не поддерживается");
		
		Возврат;
		
	КонецЕсли;
	
	ИмяБазы = Сред(ДанныеСтрокиСоединения[1], 6, СтрДлина(ДанныеСтрокиСоединения[1]) - 6);
	ПозицияРазделителя = сшпРаботаСоСтроками._СтрНайти(ДанныеСтрокиСоединения[0], ":");
	
	Если ПозицияРазделителя = 0 Тогда
		
		НомерПорта = 1541;
		
	Иначе
		
		НомерПорта = Число(Сред(ДанныеСтрокиСоединения[0], ПозицияРазделителя + 1, СтрДлина(ДанныеСтрокиСоединения[0]) - ПозицияРазделителя - 1));
		
	КонецЕсли;
	
	ИДАдаптера = "";
	ИмяАдаптера = "";
	
	Компонента = Обработки.сшпВызовыКомпоненты.Создать();     
	Компонента.ИнициализироватьКомпоненту();  

	
	Если Компонента = Неопределено Тогда
		
		Возврат;
		
	КонецЕсли;
	
	СостояниеАдаптера = Компонента.CallAsFunc("GetAdapterState", НомерПорта, ИмяБазы, ИДАдаптера, ИмяАдаптера);
	
	Компонента.CallAsProc("Stop");
	
	Если СостояниеАдаптера = 0 Тогда
		
		сшпРаботаСКонстантами.УстановитьЗначениеКонстанты("сшпОтключитьСоединение", Ложь);
		
		сшпОбщегоНазначения.УстановитьСвойстваАдаптераPipe(ИДАдаптера, ИмяАдаптера);
		
		ЗапуститьПоток("сшпPipe.ПолучениеСлужебныхСообщений", "сшпPipe.ПолучениеСлужебныхСообщений");
		ЗапуститьПоток("сшпОбслуживаниеОчередей.ОчисткаОчередейСообщений", "сшпОбслуживаниеОчередей.ОчисткаОчередейСообщений");
		
		ЗапуститьПотокОбменаТранспортнымиСообщениями();
		
	ИначеЕсли Не сшпФункциональныеОпции.ТипИспользуемогоКоннектораESB() = Перечисления.сшпТипыКоннекторовESB.Pipe Тогда 
	
		Возврат;
	
	ИначеЕсли (СостояниеАдаптера = 1) Тогда
		
		ТекстСообщения = "Не обнаружен адаптер для работы с текущей ИБ. Проверьте настройки адаптера. Имя базы = " + ИмяБазы + "; номер порта = " + НомерПорта;
		ЗарегистрироватьРезультатЗавершенияЗадания(ИмяСобытияЖР, УровеньЖурналаРегистрации.Предупреждение, ТекстСообщения);
		
		сшпРаботаСКонстантами.УстановитьЗначениеКонстанты("сшпОтключитьСоединение", Истина);
		
	ИначеЕсли (СостояниеАдаптера = 2) Тогда
		
		ТекстСообщения = "Адаптер " + ИмяАдаптера + " остановлен. Передача данных остановлена.";
		ЗарегистрироватьРезультатЗавершенияЗадания(ИмяСобытияЖР, УровеньЖурналаРегистрации.Информация, ТекстСообщения);
		
		сшпРаботаСКонстантами.УстановитьЗначениеКонстанты("сшпОтключитьСоединение", Истина);
		
	ИначеЕсли (СостояниеАдаптера = 3) Тогда
		
		ТекстСообщения = "Не обнаружен менеджер узла. Проверьте состояние сервиса Datareon на сервере 1С";
		ЗарегистрироватьРезультатЗавершенияЗадания(ИмяСобытияЖР, УровеньЖурналаРегистрации.Ошибка, ТекстСообщения);
		
		сшпРаботаСКонстантами.УстановитьЗначениеКонстанты("сшпОтключитьСоединение", Истина);
		
	Иначе
		
		ТекстСообщения = "Не удалось инициализировать подключение к адаптеру. Получено неизвестное состояние адаптера " + СостояниеАдаптера + ". Получено Id адаптера = " + ИДАдаптера + "; имя адаптера = " + ИмяАдаптера;
		ЗарегистрироватьРезультатЗавершенияЗадания(ИмяСобытияЖР, УровеньЖурналаРегистрации.Ошибка, ТекстСообщения);
		
		сшпРаботаСКонстантами.УстановитьЗначениеКонстанты("сшпОтключитьСоединение", Истина);
		
	КонецЕсли;  
	
КонецПроцедуры

//Процедура - Зарегистрировать результат завершения задания
//
//Параметры:
//	ИмяСобытияЖР - Строка - Имя события
//	Уровень - УровеньЖурналаРегистрации - Уровень важности события
//	ТекстСообщения - Строка - Произвольная строка комментария по событию
//
Процедура ЗарегистрироватьРезультатЗавершенияЗадания(ИмяСобытияЖР, Уровень, ТекстСообщения)
	            
	ЗаписьЖурналаРегистрации(ИмяСобытияЖР, Уровень, , , ТекстСообщения);
	
	Сообщение = Новый СообщениеПользователю();
	Сообщение.Текст = ТекстСообщения;
	Сообщение.Сообщить();
	
КонецПроцедуры

//Процедура - Запустить поток обмена транспортными сообщениями
//
Процедура ЗапуститьПотокОбменаТранспортнымиСообщениями()
	
	Если Не сшпФункциональныеОпции.ОтключитьПотоки() И 
		Не сшпФункциональныеОпции.ОтключитьСоединение() Тогда
		
		МаксимумПотоковВходящих = сшпРаботаСКонстантами.ПолучитьЗначениеКонстанты("сшпМаксимальноеКоличествоПотоковОбработкиВходящих");
		МаксимумПотоковИсходящих = сшпРаботаСКонстантами.ПолучитьЗначениеКонстанты("сшпМаксимальноеКоличествоПотоковОбработкиИсходящих");
		Если МаксимумПотоковВходящих = 0 ИЛИ 
			МаксимумПотоковИсходящих = 0 Тогда			
			Возврат;			
		КонецЕсли;		
		
		//Входящий поток
		МассивПараметров = Новый Массив;
		МассивПараметров.Добавить();
		
		Для Индекс = 1 По МаксимумПотоковВходящих Цикл
			
			МассивПараметров[0] = Индекс;
			ЗапуститьПоток("сшпPipe.ПолучениеТранспортныхСообщений_" + Формат(Индекс, "ЧН=0; ЧГ=0"), "сшпPipe.ПолучениеТранспортныхСообщений", МассивПараметров);
			
		КонецЦикла;
		
		//Исходящий поток
		ЗапуститьПоток("сшпPipe.ОбработкаОчередиИсходящихСообщений", "сшпPipe.ОбработкаОчередиИсходящихСообщений",);
		
		МассивПараметров = Новый Массив;
		МассивПараметров.Добавить();
		
		Для Индекс = 1 По МаксимумПотоковИсходящих Цикл
			
			МассивПараметров[0] = Индекс;
			ЗапуститьПоток("сшпPipe.ПередачаТранспортныхСообщений_" + Формат(Индекс, "ЧН=0; ЧГ=0"), "сшпPipe.ПередачаТранспортныхСообщений", МассивПараметров);
			
		КонецЦикла;
		
	КонецЕсли;

	//ПолучениеКвитанций
	ЗапуститьПоток("сшпPipe.ПолучениеКвитанций", "сшпPipe.ПолучениеКвитанций",);
	
КонецПроцедуры

//Процедура - запускает поток с ожиданием, который после паузы запускает указанный в параметрах поток
//
//Параметры:
//	ИмяМетода - строка - имя вызываемого метода
//	ПутьКМетоду - строка - имя процедуры
//	Параметры - массив - массив параметров
//	Пауза - число - количество секунд ожидания перед запуском
//
Процедура ЗапуститьПотокСЗадержкойАссинхронно(ИмяМетода, ПутьКМетоду, Параметры = Неопределено, Пауза = 1) Экспорт
	
	МассивПараметров = Новый Массив;
	МассивПараметров.Добавить(ИмяМетода);
	МассивПараметров.Добавить(ПутьКМетоду);
	МассивПараметров.Добавить(Параметры);
	МассивПараметров.Добавить(Пауза);
	
	ФоновыеЗадания.Выполнить("сшпPipe.ЗапуститьПотокСЗадержкой", массивПараметров, , "сшпPipe.ЗапуститьПотокСЗадержкой: " + ИмяМетода);
	
КонецПроцедуры

//Процедура - запускает поток с ожиданием
//
//Параметры:
//	ИмяМетода - строка - имя вызываемого метода
//	ПутьКМетоду - строка - имя процедуры
//	Параметры - массив - массив параметров
//	Пауза - число - количество секунд ожидания перед запуском
//
Процедура ЗапуститьПотокСЗадержкой(ИмяМетода, ПутьКМетоду, Параметры = Неопределено, Пауза = 1) Экспорт
	
	сшпОбщегоНазначения.Ожидание(Пауза);
	
	ЗапуститьПоток(ИмяМетода, ПутьКМетоду, Параметры);
	
КонецПроцедуры

//Процедура - запускает поток
//
//Параметры:
//	ИмяМетода - строка - имя вызываемого метода
//	ПутьКМетоду - строка - имя процедуры
//	Параметры - массив - массив параметров
//
Процедура ЗапуститьПоток(ИмяМетода, ПутьКМетоду, Параметры = Неопределено) Экспорт
	
	Попытка
		
		ФоновыеЗадания.Выполнить(ПутьКМетоду, Параметры, ИмяМетода, ИмяМетода);
		
	Исключение
		
		// Запускаем фоновое задание со статическим ключем. Запуск других экземпляров должен заканчиваться ошибкой (паттерн синглтон).
		
	КонецПопытки;
	
КонецПроцедуры

#КонецОбласти

#Область СервисныйПоток

//Процедура - Получение служебных сообщений
//
Процедура ПолучениеСлужебныхСообщений() Экспорт
	
	ВходящаяОчередь = Обработки.сшпВызовыКомпоненты.Создать();     
	ВходящаяОчередь.ИнициализироватьКомпоненту();  

	ИдАдаптера = сшпРаботаСКонстантами.ПолучитьИдАдаптера();
	
	ИмяКаналаВходящаяОчередь = ИдАдаптера + "_out_0";
	ИмяКаналаИсходящаяОчередь = ИдАдаптера + "_ack_0";
	
	Попытка
		
		ВходящаяОчередь.CallAsProc("InitServicePipe", ИмяКаналаВходящаяОчередь, ИмяКаналаИсходящаяОчередь, НомерСеансаИнформационнойБазы());
		
	Исключение
		
		ТекстОшибки = "При инициализации сервисного канала """ + ИмяКаналаВходящаяОчередь + """ произошла ошибка: " + Символы.ПС + ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		ЗапуститьПотокСЗадержкойАссинхронно("сшпPipe.ПолучениеСлужебныхСообщений", "сшпPipe.ПолучениеСлужебныхСообщений");
		сшпОбщегоНазначения.ЗарегистрироватьЗаписьВЖурнале(УровеньЖурналаРегистрации.Ошибка, "Datareon. Обработка очереди системных сообщений", ТекстОшибки);
		
		Возврат;
		
	КонецПопытки;
	
	ФорматПакета = сшпКэшируемыеФункции.ФорматСообщенийПоУмолчанию();
	ВерсияПараметровПодсистемы = сшпФункциональныеОпции.ВерсияПараметровПодсистемы();
	
	Пока Истина Цикл
		
		Если Не ПроверитьРазрешениеНаРаботу(ВерсияПараметровПодсистемы, Перечисления.сшпТипыОчередей.Системная, 0) Тогда
			
			Прервать;
			
		КонецЕсли;
		
		Попытка
			
			СообщениеПолучено = ВходящаяОчередь.CallAsFunc("GetNewMessage",1000);
			
		Исключение
			
			ТекстОшибки = "При получении сообщения из канала """ + ИмяКаналаВходящаяОчередь + """ произошла ошибка: " + Символы.ПС + ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
			ЗапуститьПотокСЗадержкойАссинхронно("сшпPipe.ПолучениеСлужебныхСообщений", "сшпPipe.ПолучениеСлужебныхСообщений");
			сшпОбщегоНазначения.ЗарегистрироватьЗаписьВЖурнале(УровеньЖурналаРегистрации.Ошибка, "Datareon. Обработка очереди системных сообщений", ТекстОшибки);
			
			Прервать;
			
		КонецПопытки;
		
		Если Не СообщениеПолучено Тогда
			
			Продолжить;
			
		КонецЕсли;
		
		ТипСообщения = ВходящаяОчередь.CallAsFunc("GetType");
		Идентификатор = ВходящаяОчередь.CallAsFunc("GetMessageId");
		КлассСообщения = ВходящаяОчередь.CallAsFunc("GetClassID");
		ТелоПакета = ВходящаяОчередь.CallAsFunc("GetMessage");
		
		Попытка
						
			//ТипСообщения = "GPS": не используется в текущем протоколе
			Если КлассСообщения = "CSM" Тогда			

				сшпСистемныеСообщения.ПолучитьСостояниеОбработки();
			
			ИначеЕсли КлассСообщения = "CSA" Тогда
				
				сткПараметры = сшпОбщегоНазначения.ПолучитьПараметрыСообщенияСтруктуройПоПакетуXML(ТелоПакета);
				
				Если сшпРаботаСДанными.УстановитьПараметрыАдаптера(сткПараметры) Тогда
					
					//изменились параметры, нужно выполнить перезапуск сеансов
					ЗапуститьПотокСЗадержкойАссинхронно("сшпPipe.НачатьОбмен", "сшпPipe.НачатьОбмен", 10);
					
				КонецЕсли;
				
			ИначеЕсли КлассСообщения = "GCM" Тогда
				
				мсвПараметры = Новый Массив;
				мсвПараметры.Добавить(Идентификатор);
				мсвПараметры.Добавить(ФорматПакета);
				мсвПараметры.Добавить(ТелоПакета);
				
				ФоновыеЗадания.Выполнить("сшпОбслуживаниеОчередей.ВыполнитьВнешнююКоманду", мсвПараметры, , "сшпОбслуживаниеОчередей.ВыполнитьВнешнююКоманду");
				
			ИначеЕсли ТипСообщения = "SUS" Тогда
				
				сткПараметры = сшпОбщегоНазначения.ПолучитьПараметрыСообщенияСтруктуройПоПакетуXML(ТелоПакета);
				мсвПараметры = Новый Массив;
				мсвПараметры.Добавить(Идентификатор);
				мсвПараметры.Добавить(сткПараметры);
				
				ФоновыеЗадания.Выполнить("сшпОбслуживаниеОчередей.УстановитьПараметрыПользователя", мсвПараметры, , "сшпОбслуживаниеОчередей.УстановитьПараметрыПользователя");
				
			ИначеЕсли КлассСообщения = "TUM" Тогда
				
				мсвПараметры = Новый Массив;
				мсвПараметры.Добавить(ФорматПакета);
				мсвПараметры.Добавить(ТелоПакета);
				
				ФоновыеЗадания.Выполнить("сшпСистемныеСообщения.ОбновитьОбработчикСобытия", мсвПараметры, Идентификатор, "ОбновитьОбработчикСобытия. id = " + Идентификатор);
				
			ИначеЕсли КлассСообщения = "TCS" Тогда
				
				мсвПараметры = Новый Массив;
				мсвПараметры.Добавить(ФорматПакета);
				мсвПараметры.Добавить(ТелоПакета);
				
				ФоновыеЗадания.Выполнить("сшпСистемныеСообщения.УправлениеСостояниемОбработчика", мсвПараметры, Идентификатор, "УправлениеСостояниемОбработчика. id = " + Идентификатор);
				
			ИначеЕсли КлассСообщения = "TRM" Тогда
				
				мсвПараметры = Новый Массив;
				мсвПараметры.Добавить(ФорматПакета);
				мсвПараметры.Добавить(ТелоПакета);
				
				ФоновыеЗадания.Выполнить("сшпСистемныеСообщения.УдалитьОбработчикСобытия", мсвПараметры, Идентификатор, "УдалитьОбработчикСобытия. id = " + Идентификатор);
				
			ИначеЕсли КлассСообщения = "TLR" Тогда
				
				ФоновыеЗадания.Выполнить("сшпСистемныеСообщения.ПолучитьСписокВерсийОбработчиковСобытий",, Идентификатор, "ПолучитьСписокВерсийОбработчиковСобытий. id = " + Идентификатор);
				
			ИначеЕсли КлассСообщения = "TSR" Тогда
				
				ФоновыеЗадания.Выполнить("сшпСистемныеСообщения.ПолучитьСписокОбработчиковСобытий",, Идентификатор, "ПолучитьСписокОбработчиковСобытий. id = " + Идентификатор);
				
			ИначеЕсли КлассСообщения = "FLR" Тогда
			
				ФоновыеЗадания.Выполнить("сшпСистемныеСообщения.ПолучитьСписокВерсийФункций",, Идентификатор, "ПолучитьСписокВерсийФункций. id = " + Идентификатор);
			
			ИначеЕсли КлассСообщения = "FSR" Тогда
			
				ФоновыеЗадания.Выполнить("сшпСистемныеСообщения.ПолучитьСписокФункций",, Идентификатор, "ПолучитьСписокФункций. id = " + Идентификатор);

			ИначеЕсли КлассСообщения = "FUM" Тогда
				
				мсвПараметры = Новый Массив;
				мсвПараметры.Добавить(ФорматПакета);
				мсвПараметры.Добавить(ТелоПакета);
				
				ФоновыеЗадания.Выполнить("сшпСистемныеСообщения.ОбновитьФункцию", мсвПараметры, Идентификатор, "ОбновитьФункцию. id = " + Идентификатор);
			
			ИначеЕсли КлассСообщения = "FCS" Тогда
				
				мсвПараметры = Новый Массив;
				мсвПараметры.Добавить(ФорматПакета);
				мсвПараметры.Добавить(ТелоПакета);
				
				ФоновыеЗадания.Выполнить("сшпСистемныеСообщения.УправлениеСостояниемФункции", мсвПараметры, Идентификатор, "УправлениеСостояниемФункции. id = " + Идентификатор);
			
			ИначеЕсли КлассСообщения = "FRM" Тогда
				
				мсвПараметры = Новый Массив;
				мсвПараметры.Добавить(ФорматПакета);
				мсвПараметры.Добавить(ТелоПакета);
				
				ФоновыеЗадания.Выполнить("сшпСистемныеСообщения.УдалитьФункцию", мсвПараметры, Идентификатор, "УдалитьФункцию. id = " + Идентификатор);
						
			ИначеЕсли КлассСообщения = "RML" Тогда
				
				мсвПараметры = Новый Массив;
				мсвПараметры.Добавить(ФорматПакета);
				мсвПараметры.Добавить(ТелоПакета);
				
				ФоновыеЗадания.Выполнить("сшпСистемныеСообщения.ВозвратПакетовВОбработку", мсвПараметры, Идентификатор, "ВозвратПакетовВОбработку. id = " + Идентификатор);
				
			ИначеЕсли КлассСообщения = "BMR" Тогда
				
				ФоновыеЗадания.Выполнить("сшпСистемныеСообщения.ПолучитьСтруктуруКонфигурации",, Идентификатор, "ПолучитьСтруктуруКонфигурации");
				
			ИначеЕсли КлассСообщения = "V1C" Тогда
				
				сшпСистемныеСообщения.ПолучитьВерсиюПодсистемы1С();
				
			ИначеЕсли КлассСообщения = "CSB" Тогда
				
				сшпСистемныеСообщения.ПолучитьПараметрыПодключения();
				
			ИначеЕсли КлассСообщения = "FND" ИЛИ ТипСообщения = "FND" Тогда    
				
				мсвПараметры = Новый Массив;
				мсвПараметры.Добавить(ФорматПакета);
				мсвПараметры.Добавить(ТелоПакета);
				мсвПараметры.Добавить(Идентификатор);
				
				ФоновыеЗадания.Выполнить("сшпСистемныеСообщения.НайтиСообщения", мсвПараметры, Идентификатор, "НайтиСообщения. id = " + Идентификатор);
				
			ИначеЕсли КлассСообщения = "DEB" ИЛИ ТипСообщения = "DEB" Тогда
				
				мсвПараметры = Новый Массив;   
				мсвПараметры.Добавить(ПолучитьФункциональнуюОпцию("сшпФорматСообщения"));
				мсвПараметры.Добавить(ТелоПакета);
				мсвПараметры.Добавить(Идентификатор);
				
				ФоновыеЗадания.Выполнить("сшпОтладкаОбработчиков.ВыполнитьОтладкуОбработчика", мсвПараметры, Идентификатор, "ВыполнитьОтладкуОбработчика. id = " + Идентификатор);
				
			Иначе
								
				Если Не ТипСообщения = "TrackMessage" Тогда		
				
					сшпСистемныеСообщения.ОтправитьСостояниеСообщения(Строка(Идентификатор), Перечисления.сшпСтатусыСообщений.НеВалидно, "Получен неизвестный тип сообщения " + Строка(ТипСообщения) + ", сообщение с данными должно иметь тип DTP", 0, Перечисления.сшпТипыИнтеграции.Входящая, КлассСообщения);
				
				КонецЕсли;
				
			КонецЕсли;
			
		Исключение
			
			ТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
			сшпОбщегоНазначения.ЗарегистрироватьЗаписьВЖурнале(УровеньЖурналаРегистрации.Ошибка, "Datareon. Обработка очереди системных сообщений", ТекстОшибки);
			
		КонецПопытки;
		
	КонецЦикла;
	
	ВходящаяОчередь.CallAsProc("Stop");
	
КонецПроцедуры

//Процедура - Установить соединение и отправить служебное сообщение
//
//Параметры:
//	XDTOПакет - Структура - содержит поля соответствующие описанию формата объекта Message1C
//
Процедура УстановитьСоединениеИОтправитьСлужебноеСообщение(XDTOПакет) Экспорт
	
	Очередь = Обработки.сшпВызовыКомпоненты.Создать();     
	Очередь.ИнициализироватьКомпоненту();  
	
	ИдАдаптера = сшпРаботаСКонстантами.ПолучитьИдАдаптера();
	
	Очередь.CallAsProc("InitDataSender", ИдАдаптера + "_datareon_server", НомерСеансаИнформационнойБазы());
	
	xmlПакет = сшпОбщегоНазначения.СформироватьСообщениеESB_HTTP(ФабрикаXDTO, XDTOПакет);
	
	ОтправитьСообщение(Очередь, xmlПакет);
	
	Очередь.CallAsProc("Stop");
	
КонецПроцедуры	

#КонецОбласти

#Область ВходящийПоток

//Функция - обрабатывает входящее сообщение
//
//Параметры:
//	Идентификатор - Строка - идентификатор передаваемого сообщения
//	КлассСообщения - Строка - класс сообщения
//	ОбъектСобытия - Структура - структура загружаемого пакета
//	СткОбработчик - Фиксированная структура - структура обработчика для входящего сообщения
//	ФорматСообщения - Перечисление.сшпФорматыСообщений - формат входящего сообщения
//	Задержка - Число - Количество секунд задержки перед обработкой
//	ТекстОшибки - Строка - возвращаемый текст ошибки
//	ДатаРегистрации - Дата - Дата/время регистрации сообщения в очереди
//	Компонента - ВнешняяКомпонента - Экземпляр внешней компоненты
//
//Возвращаемое значение:
//	Перечисление.сшпСтатусыСообщений - статус сообщения после обработки
//
Функция ВыполнитьОбработкуВходящегоСообщения(Знач Идентификатор, Знач КлассСообщения, ОбъектСобытия, СткОбработчик, Знач ФорматСообщения, Задержка, ТекстОшибки, ДатаРегистрации, Компонента);
	
	СостояниеСообщения = Перечисления.сшпСтатусыСообщений.Обработано;
	ФорматСообщенияОбертки = сшпКэшируемыеФункции.ФорматСообщенийПоУмолчанию();		
		
	Попытка
				
		ОбъектСообщение = сшпОбщегоНазначения.ПолучитьОбъектXDTO(ФорматСообщенияОбертки, ОбъектСобытия);
				
	Исключение
		
		//Сообщение не валидно
		ТекстОшибки = "Не удалось десериализовать сообщение " + ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		СостояниеСообщения = Перечисления.сшпСтатусыСообщений.НеВалидно;
		
	КонецПопытки;
		
	Если СостояниеСообщения = Перечисления.сшпСтатусыСообщений.Обработано Тогда

		КоличествоПопытокОжидания = сшпОбщегоНазначения.ПолучитьКоличествоПопытокОжидания(ОбъектСообщение);
			
		Попытка
			
			сшпОбщегоНазначения.ВыполнитьКодВходящегоОбработчика(сткОбработчик.ПроцедураОбработки, Идентификатор,
				КлассСообщения, ОбъектСобытия, СткОбработчик, ФорматСообщения, Задержка, ТекстОшибки, ДатаРегистрации,
				КоличествоПопытокОжидания, ОбъектСообщение, СостояниеСообщения);
			
		Исключение
			
			ТекстОшибки = сшпОбщегоНазначения.ДополнитьТекстОшибки(сшпОбщегоНазначения.ПолучитьТекстОшибкиОбработчика(ИнформацияОбОшибке()), СткОбработчик, Неопределено);	
				
			СостояниеСообщения = Перечисления.сшпСтатусыСообщений.ОшибкаОбработки;
			
		КонецПопытки;
		
	КонецЕсли;
	
	Возврат СостояниеСообщения;
	
КонецФункции

//Процедура - Получение транспортных сообщений
//
//Параметры:
//	ИндексПотока - Число - индекс запускаемого потока
//
Процедура ПолучениеТранспортныхСообщений(ИндексПотока) Экспорт
	
	ТекстОшибки = "";
	АварийноеЗавершение = Ложь;
	
	ВходящаяОчередь = Обработки.сшпВызовыКомпоненты.Создать();     
	ВходящаяОчередь.ИнициализироватьКомпоненту();  

	ИсходящаяОчередь = Обработки.сшпВызовыКомпоненты.Создать();     
	ИсходящаяОчередь.ИнициализироватьКомпоненту();  
	
	ИдАдаптера = сшпРаботаСКонстантами.ПолучитьИдАдаптера();
	
	ИмяКаналаВходящаяОчередь = ИдАдаптера + "_out_" + Формат(ИндексПотока, "ЧН=0; ЧГ=0;");
	
	Попытка
		
		ВходящаяОчередь.CallAsProc("InitDataReceiver", ИмяКаналаВходящаяОчередь, 
			ИдАдаптера + "_ack_" + Формат(ИндексПотока, "ЧН=0; ЧГ=0;"), НомерСеансаИнформационнойБазы());
		
	Исключение
		
		ТекстОшибки = "При инициализации транспортного канала для получения сообщений """ + ИмяКаналаВходящаяОчередь + """ произошла ошибка: " + Символы.ПС + ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());		
		сшпОбщегоНазначения.ЗарегистрироватьЗаписьВЖурнале(УровеньЖурналаРегистрации.Ошибка, "Datareon. Обработка очереди входящих сообщений", ТекстОшибки);
		
		//возможно проблема на стороне адаптера, инициализация выполнится повторно регламентным заданием
		ВызватьИсключение ТекстОшибки;
		
	КонецПопытки;
	
	Попытка
		
		ИсходящаяОчередь.CallAsProc("InitDataSender", ИдАдаптера + "_datareon_server", НомерСеансаИнформационнойБазы());
		
	Исключение
		
		ТекстОшибки = "При инициализации сервисного канала для отправки сообщений """ + ИдАдаптера + "_datareon_server" + """ произошла ошибка: " + Символы.ПС + ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());		
		ЗаписьЖурналаРегистрации("Datareon. Обработка очереди входящих сообщений", УровеньЖурналаРегистрации.Ошибка, , , ТекстОшибки);
		
		ВходящаяОчередь.CallAsProc("Stop");
		
		//возможно проблема на стороне адаптера, инициализация выполнится повторно регламентным заданием
		ВызватьИсключение ТекстОшибки;
		
	КонецПопытки;
	
	ФорматПакета = ПолучитьФункциональнуюОпцию("сшпФорматСообщения");
	ВерсияПараметровПодсистемы = сшпФункциональныеОпции.ВерсияПараметровПодсистемы();
		
	Пока Истина Цикл
		
		Если Не ПроверитьРазрешениеНаРаботу(ВерсияПараметровПодсистемы, Перечисления.сшпТипыОчередей.Входящая, ИндексПотока) Тогда
			
			Прервать;
			
		КонецЕсли;
				
		Попытка
			
			СообщениеПолучено = ВходящаяОчередь.CallAsFunc("GetNewMessage", 1000);
			
		Исключение
			
			ТекстОшибки = "При получении сообщения из канала """ + ИмяКаналаВходящаяОчередь + """ произошла ошибка: " + Символы.ПС + ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
			
			ЗапуститьПотокСЗадержкойАссинхронно("сшпPipe.ЗапуститьПотокОбменаТранспортнымиСообщениями", "сшпPipe.ЗапуститьПотокОбменаТранспортнымиСообщениями");
			
			сшпОбщегоНазначения.ЗарегистрироватьЗаписьВЖурнале(УровеньЖурналаРегистрации.Ошибка, "Datareon. Обработка очереди системных сообщений", ТекстОшибки);
			
			АварийноеЗавершение = Истина;
			
			Прервать;
			
		КонецПопытки;
				
		Если Не СообщениеПолучено Тогда
			
			Продолжить;
			
		КонецЕсли;
		
		ТипСообщения = ВходящаяОчередь.CallAsFunc("GetType");
		Идентификатор = ВходящаяОчередь.CallAsFunc("GetMessageId");
		КлассСообщения = ВходящаяОчередь.CallAsFunc("GetClassID");
				
		СткОбработчик = сшпКэшируемыеФункции.ПолучитьОбработчик(КлассСообщения, Перечисления.сшпТипыИнтеграции.Входящая, сшпФункциональныеОпции.ВерсияОбработчиков());
				
		Если Не СткОбработчик.ОбработчикНайден Тогда
			
			ПотвердитьОбработкуВходящегоСообщения(Идентификатор, ВходящаяОчередь, Перечисления.сшпСтатусыСообщений.ОтсутствуетОбработчик, , 
			"Отсутствует обработчик для класса " + КлассСообщения, КлассСообщения);
			
			Продолжить;
			
		ИначеЕсли СткОбработчик.Отключен Тогда
			
			ПотвердитьОбработкуВходящегоСообщения(Идентификатор, ВходящаяОчередь, Перечисления.сшпСтатусыСообщений.ОбработкаОтменена, ,
			"Обработчик для класса " + КлассСообщения + " найден, но отключен.", КлассСообщения);
			
			Продолжить;
			
		КонецЕсли;
			
		ОбъектСобытия = ВходящаяОчередь.CallAsFunc("GetMessage");
				
		ТекстОшибкиОбработкиСообщения = "";
		Задержка = 0;
				
		ДатаРегистрации = МестноеВремя(ВходящаяОчередь.CallAsFunc("GetCreationTime"), ЧасовойПояс());
		                     
		СостояниеСообщения = ВыполнитьОбработкуВходящегоСообщения(Идентификатор, КлассСообщения, ОбъектСобытия, сткОбработчик, форматПакета, Задержка, ТекстОшибкиОбработкиСообщения, ДатаРегистрации, ВходящаяОчередь);
		
		Если СостояниеСообщения = Перечисления.сшпСтатусыСообщений.ОжиданиеОбработки И Не ЗначениеЗаполнено(Задержка) тогда

			Задержка = 30;
	
			ТекстПредупреждения = "Задержка в ожидании обработки не может быть равна 0 с. Установлена задержка 30 с.";
	
			ЗаписьЖурналаРегистрации("Datareon. Обработка сообщения", УровеньЖурналаРегистрации.Предупреждение, ,
				Идентификатор, ТекстПредупреждения);
				
		КонецЕсли;	
				
		ПотвердитьОбработкуВходящегоСообщения(Идентификатор, ВходящаяОчередь, СостояниеСообщения, Задержка, ТекстОшибкиОбработкиСообщения, КлассСообщения);
		
		Если СостояниеСообщения = Перечисления.сшпСтатусыСообщений.НеВалидно Тогда 
			
			ЗаписьЖурналаРегистрации("Datareon. Обработка сообщения", УровеньЖурналаРегистрации.Ошибка, , Идентификатор, ТекстОшибкиОбработкиСообщения);
			
		ИначеЕсли СостояниеСообщения = Перечисления.сшпСтатусыСообщений.ОшибкаОбработки Тогда
			
			ЗаписьЖурналаРегистрации("Datareon. Обработка сообщения", УровеньЖурналаРегистрации.Ошибка, , Идентификатор, ТекстОшибкиОбработкиСообщения);
						
		КонецЕсли;
				
	КонецЦикла;
	
	ВходящаяОчередь.CallAsProc("Stop");
	ИсходящаяОчередь.CallAsProc("Stop");
	
	Если АварийноеЗавершение Тогда
		
		ВызватьИсключение ТекстОшибки;
		
	КонецЕсли;
	
КонецПроцедуры

//Процедура - Подтверждает обработку входящего сообщения
//
//Параметры:
//	Идентификатор - Строка - идентификатор сообщения
//	Очередь - ВнешняяКомпонента - экземпляр внешней компоненты обработки очереди
//	Состояние - Перечисление.сшпСтатусыСообщений - состояние сообщения
//	Задержка - Число - количество секунд обработки сообщения
//	ТекстОшибки - Строка - возвращаемый текст ошибки
//	КлассСообщения - Строка - класс выходящего сообщения
//
Процедура ПотвердитьОбработкуВходящегоСообщения(Идентификатор, Очередь, Состояние, Задержка = 0, ТекстОшибки = "", КлассСообщения = "") 
	
	КодСостояния = сшпКэшируемыеФункции.ПолучитьОбщийКодСостоянияОбработки(Состояние, Перечисления.сшпТипыИнтеграции.Входящая);
		
	Очередь.CallAsFunc("SendAckMessage", Идентификатор, КодСостояния, ТекстОшибки, КлассСообщения, Задержка);
	
КонецПроцедуры

#КонецОбласти

#Область ИсходящийПоток

//Процедура - обработка очереди исходящих сообщения
//
Процедура ОбработкаОчередиИсходящихСообщений() Экспорт 

	КоличествоСообщенийБуфера = 50;
	ДлительностьОжиданияКвитанций = 600; //в секундах
	КоличествоПотоков = сшпРаботаСКонстантами.МаксимальноеКоличествоПотоковОбработкиИсходящих();
			
	Запрос = Новый Запрос;		
	Запрос.Текст =
		"ВЫБРАТЬ ПЕРВЫЕ " + Формат(КоличествоПотоков*КоличествоСообщенийБуфера, "ЧГ=0") + "
		|	сшпСостояниеСообщений.ИндексПотока КАК ИндексПотока,
		|	1 КАК Количество
		|ПОМЕСТИТЬ ВТРезультатВОбработке
		|ИЗ
		|	РегистрСведений.сшпСостояниеСообщений КАК сшпСостояниеСообщений
		|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.сшпОчередьИсходящихСообщений КАК сшпОчередьИсходящихСообщений
		|		ПО сшпСостояниеСообщений.ИдентификаторСобытия = сшпОчередьИсходящихСообщений.ИдентификаторСобытия
		|ГДЕ
		|	сшпСостояниеСообщений.СтатусСообщения = ЗНАЧЕНИЕ(Перечисление.сшпСтатусыСообщений.ВОбработке)
		|	И сшпСостояниеСообщений.ЗадержкаЧисло <= &Задержка
		|УПОРЯДОЧИТЬ ПО
		|	сшпОчередьИсходящихСообщений.ДатаРегистрации
		|;
		|
		|////////////////////////////////////////////////////////////////////////////////
		|ВЫБРАТЬ ПЕРВЫЕ " + Формат(КоличествоПотоков*КоличествоСообщенийБуфера, "ЧГ=0") + "
		|	сшпСостояниеСообщений.ИндексПотока КАК ИндексПотока,
		|	сшпСостояниеСообщений.СтатусСообщения КАК СтатусСообщения,
		|	сшпОчередьИсходящихСообщений.ИдентификаторСобытия КАК ИдентификаторСобытия
		|ПОМЕСТИТЬ кРаспределениюРабочие
		|ИЗ
		|	РегистрСведений.сшпОчередьИсходящихСообщений КАК сшпОчередьИсходящихСообщений
		|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.сшпСостояниеСообщений КАК сшпСостояниеСообщений
		|		ПО сшпОчередьИсходящихСообщений.ИдентификаторСобытия = сшпСостояниеСообщений.ИдентификаторСобытия
		|ГДЕ
		|	сшпСостояниеСообщений.СтатусСообщения В(&СтатусСообщенияКАнализу)
		|	И сшпСостояниеСообщений.ЗадержкаЧисло <= &Задержка
		|	И сшпСостояниеСообщений.ИндексПотока = 0
		|УПОРЯДОЧИТЬ ПО
		|	сшпОчередьИсходящихСообщений.ДатаРегистрации
		|;
		|
		|////////////////////////////////////////////////////////////////////////////////
		|ВЫБРАТЬ
		|	кРаспределению.ИдентификаторСобытия КАК ИдентификаторСобытия,
		|	кРаспределению.СтатусСообщения КАК СтатусСообщения
		|ИЗ
		|	кРаспределениюРабочие КАК кРаспределению
		|ГДЕ
		|	кРаспределению.СтатусСообщения В(&СтатусСообщенияНераспределенные)
		|;
		|
		|////////////////////////////////////////////////////////////////////////////////
		|ВЫБРАТЬ
		|	кРаспределению.ИндексПотока КАК ИндексПотока,
		|	СУММА(1) КАК Количество
		|ПОМЕСТИТЬ ВТКоличествоСообщений
		|ИЗ
		|	кРаспределениюРабочие КАК кРаспределению
		|ГДЕ
		|	кРаспределению.ИндексПотока <> 0
		|
		|СГРУППИРОВАТЬ ПО
		|	кРаспределению.ИндексПотока
		|
		|ОБЪЕДИНИТЬ ВСЕ
		|
		|ВЫБРАТЬ
		|	ВТРезультатВОбработке.ИндексПотока,
		|	ВТРезультатВОбработке.Количество
		|ИЗ
		|	ВТРезультатВОбработке КАК ВТРезультатВОбработке
		|;
		|
		|////////////////////////////////////////////////////////////////////////////////
		|ВЫБРАТЬ
		|	ВТКоличествоСообщений.ИндексПотока КАК ИндексПотока,
		|	СУММА(ВТКоличествоСообщений.Количество) КАК Количество
		|ИЗ
		|	ВТКоличествоСообщений КАК ВТКоличествоСообщений
		|
		|СГРУППИРОВАТЬ ПО
		|	ВТКоличествоСообщений.ИндексПотока";
		
	СтатусСообщенияНераспределенные = сшпКэшируемыеФункции.ПоучитьСписокРабочихСтатусов();	
		
	Запрос.УстановитьПараметр("СтатусСообщенияКАнализу", СтатусСообщенияНераспределенные);
	Запрос.УстановитьПараметр("СтатусСообщенияНераспределенные", СтатусСообщенияНераспределенные);	
	
	ЗапросПоискЗависших = Новый Запрос;
	ЗапросПоискЗависших.Текст = 
		"ВЫБРАТЬ
		|	сшпОчередьИсходящихСообщений.ИдентификаторСобытия КАК Идентификатор
		|ИЗ
		|	РегистрСведений.сшпОчередьИсходящихСообщений КАК сшпОчередьИсходящихСообщений
		|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.сшпСостояниеСообщений КАК сшпСостояниеСообщений
		|		ПО сшпОчередьИсходящихСообщений.ИдентификаторСобытия = сшпСостояниеСообщений.ИдентификаторСобытия
		|ГДЕ
		|	сшпСостояниеСообщений.СтатусСообщения = ЗНАЧЕНИЕ(Перечисление.сшпСтатусыСообщений.ВОбработке)
		|	И (сшпСостояниеСообщений.ИндексПотока > &КоличествоПотоков
		|			ИЛИ сшпСостояниеСообщений.ИндексПотока = 0)
		|
		|ОБЪЕДИНИТЬ ВСЕ
		|
		|ВЫБРАТЬ
		|	сшпОчередьИсходящихСообщений.ИдентификаторСобытия
		|ИЗ
		|	РегистрСведений.сшпОчередьИсходящихСообщений КАК сшпОчередьИсходящихСообщений
		|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.сшпСостояниеСообщений КАК сшпСостояниеСообщений
		|		ПО сшпОчередьИсходящихСообщений.ИдентификаторСобытия = сшпСостояниеСообщений.ИдентификаторСобытия
		|ГДЕ
		|	сшпСостояниеСообщений.СтатусСообщения = ЗНАЧЕНИЕ(Перечисление.сшпСтатусыСообщений.Отправлено)
		|	И сшпСостояниеСообщений.ДатаИзменения < &ДатаОтправки";	
	ЗапросПоискЗависших.УстановитьПараметр("КоличествоПотоков", КоличествоПотоков);
	
	Пока сшпФункциональныеОпции.ИспользоватьСШП() И 
		Не сшпФункциональныеОпции.ОтключитьПотоки() И 
		Не сшпФункциональныеОпции.ОтключитьСоединение() Цикл 
		
		Запрос.УстановитьПараметр("Задержка", сшпОбщегоНазначения.ПеревестиДатуВЧисло(ТекущаяДатаСеанса()));
		
		//@skip-check query-in-loop
		РезультатЗапроса = Запрос.ВыполнитьПакет();
		//РезультатЗапроса[2]: идентификаторы нераспределенных сообщений
		//РезультатЗапроса[4]: количество сообщений, находящиеся сейчас в обработке по каждому потоку
		
		СделатьПаузу = Истина;
		
		Если Не РезультатЗапроса[2].Пустой() Тогда //есть сообщения к распределению
			
			СделатьПаузу = Ложь;
			
			ВыборкаИдентификаторов = РезультатЗапроса[2].Выбрать();
			ВыборкаПотоков = РезультатЗапроса[4].Выбрать();
			
			ИндексПотока = 0;		
			КоличествоВПотоке = КоличествоСообщенийБуфера; //инициализируем первое значение, превышающее буфер для перехода на следующий поток			
			ЕстьИзменения = Ложь;
			
			Пока ВыборкаИдентификаторов.Следующий() Цикл
				
				Пока КоличествоСообщенийБуфера <= КоличествоВПотоке Цикл    //буфер потока переполнен, перейдем к следующему
					
					ИндексПотока = ИндексПотока + 1;
					
					Если ВыборкаПотоков.НайтиСледующий(ИндексПотока, "ИндексПотока") Тогда 
						
						КоличествоВПотоке = ВыборкаПотоков.Количество;
						
					Иначе
						
						КоличествоВПотоке = 0;
						
					КонецЕсли;
					
				КонецЦикла;
				
				Если ИндексПотока > КоличествоПотоков Тогда
					
					Если Не ЕстьИзменения Тогда
						сшпОбщегоНазначения.ОжиданиеМСек(100);
						СделатьПаузу = Ложь;	
					Иначе
						СделатьПаузу = Истина;
					Конецесли;
					
					Прервать;
					
				КонецЕсли;
				
				ЕстьИзменения = Истина;
				
				текИдентификатор = ВыборкаИдентификаторов.ИдентификаторСобытия;
				сшпРаботаСДанными.УстановитьСостояниеСообщения(текИдентификатор, Перечисления.сшпСтатусыСообщений.ВОбработке, , , ИндексПотока, , Перечисления.сшпТипыИнтеграции.Исходящая);
				
				КоличествоВПотоке = КоличествоВПотоке + 1;
				
			КонецЦикла;
			
		КонецЕсли;		
		
		ЗапросПоискЗависших.УстановитьПараметр("ДатаОтправки", ТекущаяДатаСеанса() - ДлительностьОжиданияКвитанций);
		//@skip-check query-in-loop
		РезультатПоискаЗависших = ЗапросПоискЗависших.Выполнить();
		
		Если Не РезультатПоискаЗависших.Пустой() Тогда
			
			СделатьПаузу = Ложь;
			
			ВыборкаДетальныеЗаписи = РезультатПоискаЗависших.Выбрать();
			
			Пока ВыборкаДетальныеЗаписи.Следующий() Цикл
				
				сшпРаботаСДанными.УстановитьСостояниеСообщения(ВыборкаДетальныеЗаписи.Идентификатор, Перечисления.сшпСтатусыСообщений.ОжиданиеОбработки, , , , , Перечисления.сшпТипыИнтеграции.Исходящая);
				
			КонецЦикла;
			
		КонецЕсли;
		
		Если СделатьПаузу Тогда
			
			сшпОбщегоНазначения.Ожидание(1);
			
		КонецЕсли;

	КонецЦикла;
	
КонецПроцедуры

//Процедура - Передача транспортных сообщений
//
//Параметры:
//	ИндексПотока - Число - индекс потока
// 
Процедура ПередачаТранспортныхСообщений(ИндексПотока) Экспорт 

	ИсходящаяОчередь = Обработки.сшпВызовыКомпоненты.Создать();     
	ИсходящаяОчередь.ИнициализироватьКомпоненту(); 
	
	ИдАдаптера = сшпРаботаСКонстантами.ПолучитьИдАдаптера();
	
	Попытка
		
		ИсходящаяОчередь.CallAsProc("InitDataSender", ИдАдаптера + "_datareon_server", НомерСеансаИнформационнойБазы());
		
	Исключение
		
		ТекстОшибки = "При инициализации транспортного канала для передачи сообщений """ + ИдАдаптера + "_datareon_server" + """ произошла ошибка: " + Символы.ПС + ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		ЗаписьЖурналаРегистрации("Datareon. Обработка очереди исходящих сообщений", УровеньЖурналаРегистрации.Ошибка, , , ТекстОшибки);

		Возврат;
		
	КонецПопытки;
			
	ФорматСообщения = сшпКэшируемыеФункции.ФорматСообщенийПоУмолчанию();
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
	"ВЫБРАТЬ ПЕРВЫЕ 50
	|	сшпСостояниеСообщений.СтатусСообщения КАК СтатусСообщения,
	|	сшпОчередьИсходящихСообщений.ИдентификаторСобытия КАК ИдентификаторСобытия,
	|	сшпСостояниеСообщений.ИдентификаторСообщения,
	|	сшпОчередьИсходящихСообщений.Хранилище КАК Хранилище,
	|	сшпОчередьИсходящихСообщений.ДатаРегистрации КАК ДатаРегистрации,
	|	сшпОчередьИсходящихСообщений.ОбъектСобытия КАК ОбъектСобытия,
	|	сшпОчередьИсходящихСообщений.ФорматСообщения КАК ФорматСообщения,
	|	сшпОчередьИсходящихСообщений.МетодХранения КАК МетодХранения,
	|	сшпОчередьИсходящихСообщений.ЭтоУдаление КАК ЭтоУдаление,
	|	сшпОчередьИсходящихСообщений.СсылкаНаОбъект КАК СсылкаНаОбъект
	|ИЗ
	|	РегистрСведений.сшпОчередьИсходящихСообщений КАК сшпОчередьИсходящихСообщений
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.сшпСостояниеСообщений КАК сшпСостояниеСообщений
	|		ПО сшпОчередьИсходящихСообщений.ИдентификаторСобытия = сшпСостояниеСообщений.ИдентификаторСобытия
	|ГДЕ
	|	сшпСостояниеСообщений.СтатусСообщения = ЗНАЧЕНИЕ(Перечисление.сшпСтатусыСообщений.ВОбработке)
	|	И сшпСостояниеСообщений.ИндексПотока = &ИндексПотока";
		
	СтатусСообщенияНераспределенные = сшпКэшируемыеФункции.ПоучитьСписокРабочихСтатусов();
	
	СтатусСообщенияКАнализу = сшпКэшируемыеФункции.ПоучитьСписокРабочихСтатусов();
	
	СтатусСообщенияКАнализу.Добавить(Перечисления.сшпСтатусыСообщений.ВОбработке);
		
	Запрос.УстановитьПараметр("ИндексПотока", ИндексПотока);
	ВерсияПараметровПодсистемы = сшпФункциональныеОпции.ВерсияПараметровПодсистемы();
		
	Пока Истина Цикл
				
		Если Не ПроверитьРазрешениеНаРаботу(ВерсияПараметровПодсистемы, Перечисления.сшпТипыОчередей.Исходящая, ИндексПотока) Тогда
			
			Прервать;
			
		КонецЕсли;
			
		РезультатЗапроса = Запрос.Выполнить();
			
		Если РезультатЗапроса.Пустой() Тогда //нечего обрабатывать
			
			сшпОбщегоНазначения.Ожидание(1);
			
		Иначе
						
			Выборка = РезультатЗапроса.Выбрать();
			
			Пока Выборка.Следующий() Цикл 
				
				ИдентификаторСобытия = Выборка.ИдентификаторСобытия;
				ИдентификаторСообщения = Выборка.ИдентификаторСообщения;								
								
				сткОбработчик = сшпКэшируемыеФункции.ПолучитьОбработчик(Выборка.ОбъектСобытия, Перечисления.сшпТипыИнтеграции.Исходящая, сшпФункциональныеОпции.ВерсияОбработчиков());
								
				Если Не сткОбработчик.ОбработчикНайден Тогда
					
					сшпРаботаСДанными.УстановитьСостояниеСообщения(ИдентификаторСобытия, Перечисления.сшпСтатусыСообщений.ОтсутствуетОбработчик, , , , , Перечисления.сшпТипыИнтеграции.Исходящая);
					
				ИначеЕсли сткОбработчик.Отключен тогда
					
					сшпРаботаСДанными.УстановитьСостояниеСообщения(ИдентификаторСобытия, Перечисления.сшпСтатусыСообщений.ОбработкаОтменена, , , , , Перечисления.сшпТипыИнтеграции.Исходящая);
					
				Иначе
					
					Задержка = 0;
					ТекстОшибки = "";
					ДопСвойства = Неопределено;
										
					Объектсобытия = Выборка.Хранилище.Получить();
					
					РезультатОбработки = сшпОбщегоНазначения.СформироватьСтруктуруПакета();
								
					НовыйСтатус = сшпОбщегоНазначения.ПолучитьСтатусСобытия(ИдентификаторСобытия);
					Если Не НовыйСтатус = Перечисления.сшпСтатусыСообщений.ВОбработке Тогда
						Продолжить;
					КонецЕсли;								
								
					СостояниеСообщения = СформироватьИсходящееСообщение(РезультатОбработки, ИдентификаторСообщения, ИдентификаторСобытия, Выборка.ОбъектСобытия, Выборка.методхранения, Объектсобытия, Задержка, сткОбработчик, Выборка.ФорматСообщения, ТекстОшибки, Выборка.ДатаРегистрации, Выборка.ЭтоУдаление, Выборка.СсылкаНаОбъект);
															
					Если СостояниеСообщения = Перечисления.сшпСтатусыСообщений.Обработано Тогда
							
						сшпОбщегоНазначения.УстановитьСвойствоПоиска(Выборка.СсылкаНаОбъект, РезультатОбработки);
												
						СостояниеСообщения = ОтправитьТранспортноеСообщение(ИсходящаяОчередь, РезультатОбработки); 
												
						Если СостояниеСообщения = Перечисления.сшпСтатусыСообщений.НеВалидно Тогда
							
							СостояниеСообщения = РезультатОбработки;
							
						ИначеЕсли СостояниеСообщения = Перечисления.сшпСтатусыСообщений.ОшибкаОбработки Тогда 
							
							ЗапуститьПотокСЗадержкойАссинхронно("сшпPipe.ЗапуститьПотокОбменаТранспортнымиСообщениями", "сшпPipe.ЗапуститьПотокОбменаТранспортнымиСообщениями");
														
							Прервать;
							
						КонецЕсли;
						
					ИначеЕсли Не СостояниеСообщения = Перечисления.сшпСтатусыСообщений.ОбработкаОтменена И 
								Не СостояниеСообщения = Перечисления.сшпСтатусыСообщений.ОшибкаОбработки И 
								Не СостояниеСообщения = Перечисления.сшпСтатусыСообщений.ОжиданиеОбработки Тогда
						
						СостояниеСообщения = Перечисления.сшпСтатусыСообщений.ОжиданиеОбработки;
						Задержка = 30;
						
					ИначеЕсли СостояниеСообщения = Перечисления.сшпСтатусыСообщений.ОшибкаОбработки Тогда
												
						ТекстОшибки = сшпОбщегоНазначения.ДополнитьТекстОшибки(ТекстОшибки, сткОбработчик, Выборка.СсылкаНаОбъект);
						ДопСвойства = сшпОбщегоНазначения.ПолучитьИдентификаторОбъектаСобытия(Объектсобытия);
						
					КонецЕсли;
					
					сшпРаботаСДанными.УстановитьСостояниеСообщения(ИдентификаторСобытия, СостояниеСообщения, Задержка, ТекстОшибки, , , Перечисления.сшпТипыИнтеграции.Исходящая, Выборка.ОбъектСобытия, ИдентификаторСообщения, ДопСвойства);
				
				КонецЕсли;
				
			КонецЦикла;
						
		КонецЕсли;
		
	КонецЦикла;
	
	ИсходящаяОчередь.CallAsProc("Stop");
	
КонецПроцедуры

//Функция - сформировать исходящее сообщение
//
//Параметры:
//	РезультатОбработки - структура - структура пакета, который будет выгружен из 1С
//	Идентификатор - строка - идентификатор сообщения
//	ИдентификаторСобытия - строка - идентификатор события
//	ТипОбъекта - строка - полное имя метаданных, которые вызвали обработку события
//	МетодХранения - Перечисление.сшпМетодХранения - метод хранения объекта
//	ОбъектСобытия - ЛюбаяСсылка, Отбор, ОбъектXDTO - зарегистрированный к выгрузке объект
//	Задержка - число - Количество секунд задержки перед обработкой
//	СткОбработчик - фиксированная структура - структура обработчика для исходящего сообщения
//	ФорматСообщения - Перечисление.сшпФорматыСообщений - формат исходящего сообщения
//	ТекстОшибки - строка - возвращаемый текст ошибки
//	ДатаРегистрации - Дата - Дата регистрации сообщения
//	ЭтоУдаление - Булево - Признак удаления
//	СсылкаНаОбъект - ЛюбаяСсылка - Ссылка на объект
//
//Возвращаемое значение:
//	Перечисление.сшпСтатусыСообщений - статус сообщения после обработки
//
Функция СформироватьИсходящееСообщение(РезультатОбработки, Идентификатор, ИдентификаторСобытия, ТипОбъекта, МетодХранения, ОбъектСобытия, Задержка, СткОбработчик, ФорматСообщения, ТекстОшибки, ДатаРегистрации, ЭтоУдаление, СсылкаНаОбъект)
	
	РезультатОбработки = сшпОбщегоНазначения.СформироватьСтруктуруПакета();
	РезультатОбработки.Id = Идентификатор;
	
	СостояниеСообщения = Перечисления.сшпСтатусыСообщений.Обработано;
	
	ЭтоОшибкаБлокировок = Ложь;
	
	Попытка
		
		ОбъектОбработки = Неопределено;
		
		Если МетодХранения = Перечисления.сшпМетодХранения.ПоСсылке Тогда
			
			Если ТипЗнч(ОбъектСобытия) = Тип("Отбор") Тогда
				
				ТипРегистра = сшпКэшируемыеФункции.ПолучитьТипОбъекта(ТипОбъекта);
				ИмяРегистра = сшпКэшируемыеФункции.ПолучитьИмяОбъекта(ТипОбъекта);
				
				Если ТипРегистра = "РегистрСведений" Тогда
					
					ОбъектОбработки = РегистрыСведений[ИмяРегистра].СоздатьНаборЗаписей();	
					
				ИначеЕсли ТипРегистра = "РегистрНакопления" Тогда
					
					ОбъектОбработки = РегистрыНакопления[ИмяРегистра].СоздатьНаборЗаписей();
					
				ИначеЕсли ТипРегистра = "РегистрБухгалтерии" Тогда
					
					ОбъектОбработки = РегистрыБухгалтерии[ИмяРегистра].СоздатьНаборЗаписей();
					
				ИначеЕсли ТипРегистра = "РегистрРасчета" Тогда
					
					ОбъектОбработки = РегистрыРасчета[ИмяРегистра].СоздатьНаборЗаписей();
					
				Иначе
					
					ВызватьИсключение "Тип: " + ТипРегистра + " не поддерживается текущей версией подсистемы ESB";
					
				КонецЕсли;
				
				Для Каждого ЭлементОтбор Из ОбъектСобытия Цикл
					
					ЗаполнитьЗначенияСвойств(ОбъектОбработки.Отбор[элементОтбор.Имя], ЭлементОтбор);
				
				КонецЦикла;
				
				Попытка
					
					ОбъектОбработки.Прочитать();
						
				Исключение
					
					ЭтоОшибкаБлокировок = сшпОбщегоНазначения.ЭтоОшибкаКонфликтаБлокировок(ОписаниеОшибки());
					
					ВызватьИсключение;
					
				КонецПопытки;
				
			Иначе
				
				ОбъектОбработки = ОбъектСобытия;
				
				//Проверка акутальности данных в объектном кеше для объектов
				Если сшпКэшируемыеФункции.ПроверятьАктуальностьОбъектногоКеша() И ЗначениеЗаполнено(СсылкаНаОбъект) И
					Не сшпРаботаСДанными.ОбъектныйКешАктуален(СсылкаНаОбъект, ТипОбъекта) Тогда 
					СостояниеСообщения = Перечисления.сшпСтатусыСообщений.ОжиданиеОбработки;
					Задержка = сшпКэшируемыеФункции.ВремяОжиданияПриНеактуальномОбъектномКеше();
					ТекстОшибки = "Обработка отложена из-за неактуальности версий в объектном кеше";
					
					Возврат СостояниеСообщения;

				КонецЕсли;
				
			КонецЕсли;
			
		Иначе	
			
			ОбъектОбработки = сшпОбщегоНазначения.ДесериализоватьОбъект(ФорматСообщения, ОбъектСобытия);
			
		КонецЕсли;
		
		сшпОбщегоНазначения.ВыполнитьКодИсходящегоОбработчика(сткОбработчик.ПроцедураОбработки, РезультатОбработки,
			Идентификатор, ИдентификаторСобытия, ТипОбъекта, МетодХранения, ОбъектСобытия, Задержка, СткОбработчик,
			ФорматСообщения, ТекстОшибки, ДатаРегистрации, ЭтоУдаление, СсылкаНаОбъект, ОбъектОбработки,
			СостояниеСообщения);
		
	Исключение
		
		Если ЭтоОшибкаБлокировок тогда

			ЗаписьЖурналаРегистрации("Datareon. Получение объекта события", УровеньЖурналаРегистрации.Предупреждение, ,
				ИдентификаторСобытия, "Ошибка конфликта блокировок при чтении набора записей регистра. Обработка отложена.");
	
			СостояниеСообщения = Перечисления.сшпСтатусыСообщений.ОжиданиеОбработки;
			Задержка = 10;
			
		Иначе	

			ТекстОшибки = сшпОбщегоНазначения.ПолучитьТекстОшибкиОбработчика(ИнформацияОбОшибке());
			
			СостояниеСообщения = Перечисления.сшпСтатусыСообщений.ОшибкаОбработки;
			
		КонецЕсли;
		
	КонецПопытки;
	
	Возврат СостояниеСообщения;
	
КонецФункции

//Процедура - Получение квитанции
//
Процедура ПолучениеКвитанций() Экспорт
	
	ИдАдаптера = сшпРаботаСКонстантами.ПолучитьИдАдаптера();
	
	ВходящаяОчередьКвитанций = Обработки.сшпВызовыКомпоненты.Создать();     
	ВходящаяОчередьКвитанций.ИнициализироватьКомпоненту();  
	
	Попытка
		
		ВходящаяОчередьКвитанций.CallAsProc("InitDataSender", ИдАдаптера + "_1c_server", НомерСеансаИнформационнойБазы());
		
	Исключение
		
		ТекстОшибки = "При инициализации сервисного канала для получения квитанций """ + ИдАдаптера + "_1c_server" + """ произошла ошибка: " + Символы.ПС + ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());

		ЗапуститьПотокСЗадержкойАссинхронно("сшпPipe.ПолучениеКвитанций", "сшпPipe.ПолучениеКвитанций");
		сшпОбщегоНазначения.ЗарегистрироватьЗаписьВЖурнале(УровеньЖурналаРегистрации.Ошибка, "Datareon. Обработка очереди входящих сообщений", ТекстОшибки);
		
		Возврат;
		
	КонецПопытки;
	
	Пока сшпФункциональныеОпции.ИспользоватьСШП() И 
		Не сшпФункциональныеОпции.ОтключитьСоединение() Цикл 
		
		Идентификатор = "";
		ТекстСообщения = "";
		
		Попытка
			
			РезультатОбработки = ВходящаяОчередьКвитанций.CallAsFunc("GetMessageHandleResult", Идентификатор, ТекстСообщения);
			
		Исключение
			
			ТекстОшибки = "При получении сообщения из сервисного канала квитанций """ + ИдАдаптера + "_1c_server" + """ произошла ошибка: " + Символы.ПС + ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
			
			ЗапуститьПотокСЗадержкойАссинхронно("сшпPipe.ПолучениеКвитанций", "сшпPipe.ПолучениеКвитанций");
			сшпОбщегоНазначения.ЗарегистрироватьЗаписьВЖурнале(УровеньЖурналаРегистрации.Ошибка, "Datareon. Обработка очереди системных сообщений", ТекстОшибки);
			
			Прервать;
			
		КонецПопытки;
		
		Если (РезультатОбработки >= 0) Тогда
			
			СостояниеСообщения = сшпКэшируемыеФункции.ПолучитьОбщееСостояниеОбработкиСообщенияПоКоду(РезультатОбработки);
			сшпРаботаСДанными.УстановитьСостояниеСообщения(Идентификатор, СостояниеСообщения, 0, ТекстСообщения , , , Перечисления.сшпТипыИнтеграции.Исходящая, , Идентификатор);
			
		Иначе
			
			сшпОбщегоНазначения.Ожидание(1);	
			
		КонецЕсли;
		
	КонецЦикла;
	
	ВходящаяОчередьКвитанций.CallAsProc("Stop");
	
КонецПроцедуры

//Функция - Отправить транспортное сообщение
//
//Параметры:
//	Очередь - ВнешняяКомпонента - экземпляр внешней компоненты текущей очереди
//	СтруктураСообщения - структура - структура передаваемого сообщения
//
//Возвращаемое значение:
//	Перечисление.сшпСтатусыСообщений - статус сообщения после обработки
//
Функция ОтправитьТранспортноеСообщение(Очередь, СтруктураСообщения) Экспорт
		
	Попытка
		
		xmlПакет = сшпОбщегоНазначения.СформироватьСообщениеESB_HTTP(ФабрикаXDTO, СтруктураСообщения);
			
	Исключение
		
		ТекстОшибки = "Не удалось сериализовать исходящее сообщение " + СтруктураСообщения.Id + " по причине:"
			+ Символы.ПС + ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());	
		ЗаписьЖурналаРегистрации("Datareon. Обработка очереди исходящих сообщений", УровеньЖурналаРегистрации.Ошибка, , , ТекстОшибки);		
		ЗарегистрироватьОшибку(Очередь, ТекстОшибки);
		
		Возврат Перечисления.сшпСтатусыСообщений.НеВалидно;
		
	КонецПопытки;
	
	Попытка

		ОтправитьСообщение(Очередь, xmlПакет);
		
	Исключение
		
		ТекстОшибки = "Не удалось отправить исходящее сообщение " + СтруктураСообщения.Id + " по причине:"
			+ Символы.ПС + ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());	
		ЗаписьЖурналаРегистрации("Datareon. Обработка очереди исходящих сообщений", УровеньЖурналаРегистрации.Предупреждение, , , ТекстОшибки);
		
		Возврат Перечисления.сшпСтатусыСообщений.ОшибкаОбработки;
		
	КонецПопытки;
	
	Возврат Перечисления.сшпСтатусыСообщений.Отправлено;
	
КонецФункции	

//Процедура - Отправить сообщение
//
//Параметры:
//	Очередь - ВнешняяКомпонента - экземпляр внешней компоненты
//	xmlПакет - ЗаписьXML - передаваемый пакет
//
Процедура ОтправитьСообщение(Очередь, xmlПакет) Экспорт
	
	Очередь.CallAsFunc("SendMessage", xmlПакет);
	
КонецПроцедуры	

//Функция - Отправить сообщение об ошибке
//
//Параметры:
//	Очередь - ВнешняяКомпонента - экземпляр внешней компоненты
//	Класс - Строка - класс сообщения
//	Описание - Строка - тело пакета
//	Свойства - Структура - дополнительные свойства
//
//Возвращаемое значение:
//	Строка - текст ошибки
//
Функция ОтправитьСообщениеОбОшибке(Очередь, Класс, Описание, Свойства) Экспорт
	
	Попытка
		
		Сообщение = сшпОбщегоНазначения.СформироватьСтруктуруПакета("TER", Класс, Описание);
		Сообщение.Properties = Свойства;
		
		xmlПакет = сшпОбщегоНазначения.СформироватьСообщениеESB_HTTP(ФабрикаXDTO, Сообщение);
		
	Исключение
		
		ТекстОшибки = "Не удалось сериализовать сообщение класса TER по причине:"
			+ Символы.ПС + ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());	
		ЗаписьЖурналаРегистрации("Datareon. Обработка очереди исходящих сообщений", УровеньЖурналаРегистрации.Ошибка, , , ТекстОшибки);
		
		ЗарегистрироватьОшибку(Очередь, ТекстОшибки);
		
		Возврат "";
		
	КонецПопытки;
	
	Попытка
		
		ОтправитьСообщение(Очередь, xmlПакет);
		
	Исключение
		
		ТекстОшибки = "Не удалось отправить сообщение класса TER по причине:"
			+ Символы.ПС + ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());	
			
		ЗаписьЖурналаРегистрации("Datareon. Обработка очереди сообщений", УровеньЖурналаРегистрации.Предупреждение, , , ТекстОшибки);
		
		Возврат ТекстОшибки;
		
	КонецПопытки;
	
	Возврат "";
	
КонецФункции	

// Функция - Отправить сообщение без очереди
//
// Параметры:
//  Сообщение	 - Структура - Структура описывающая состав отправляемого сообщения.
// 
// Возвращаемое значение:
//  Булево - Признак успешности отправки сообщения на адаптер.
//
Функция ОтправитьСообщениеБезОчереди(Сообщение) Экспорт
	
	ОтправкаРезультат = Истина;
	
	Попытка
		
		ИсходящаяОчередь = Обработки.сшпВызовыКомпоненты.Создать();     
		ИсходящаяОчередь.ИнициализироватьКомпоненту();  
		
		ИдАдаптера = сшпРаботаСКонстантами.ПолучитьИдАдаптера();
		
		Попытка
			
			ИсходящаяОчередь.CallAsProc("InitDataSender", ИдАдаптера + "_datareon_server", НомерСеансаИнформационнойБазы());
			
		Исключение
			
			ТекстОшибки = "При инициализации транспортного канала для передачи сообщений """ + ИдАдаптера + "_datareon_server" + """ произошла ошибка: " + Символы.ПС + ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
			ЗаписьЖурналаРегистрации("Datareon. Обработка очереди исходящих сообщений", УровеньЖурналаРегистрации.Ошибка, , , ТекстОшибки);

			Возврат Ложь;
			
		КонецПопытки;

		ОтправитьТранспортноеСообщение(ИсходящаяОчередь, Сообщение);
		
		ИсходящаяОчередь.CallAsProc("Stop");
		
	Исключение
		
		ИнформацияОбОшибке = ИнформацияОбОшибке();
		ЗаписьЖурналаРегистрации("Datareon. Помещение сообщения в очередь на отправку", УровеньЖурналаРегистрации.Ошибка, , , ПодробноеПредставлениеОшибки(ИнформацияОбОшибке));
		ОтправкаРезультат = Ложь;
	
	КонецПопытки;
	
	Возврат ОтправкаРезультат;

КонецФункции

#КонецОбласти

#Область Логирование

//Процедура Зарегистрировать ошибку
//
//Параметры:
//	Очередь - ВнешняяКомпонента - экземпляр внешней компоненты
//	Сообщение - Строка - строка сообщения об ошибке
//
Процедура ЗарегистрироватьОшибку(Очередь, Сообщение)
	
	Очередь.CallAsProc("WriteLog", 3, Сообщение);
	
КонецПроцедуры

//Процедура Зарегистрировать предупреждение
//
//Параметры:
//	Очередь - ВнешняяКомпонента - экземпляр внешней компоненты
//	Сообщение - Строка - строка сообщения о предупреждении
//
Процедура ЗарегистрироватьПредупреждение(Очередь, Сообщение)
	
	Очередь.CallAsProc("WriteLog", 2, Сообщение);
	
КонецПроцедуры

//Процедура Зарегистрировать информационное сообщение
//
//Параметры:
//	Очередь - ВнешняяКомпонента - экземпляр внешней компоненты
//	Сообщение - Строка - строка информационного сообщения
//
Процедура ЗарегистрироватьИнформационноеСообщение(Очередь, Сообщение)
	
	Очередь.CallAsProc("WriteLog", 1, Сообщение);
	
КонецПроцедуры

//Процедура Зарегистрировать отладочное сообщение
//
//Параметры:
//	Очередь - ВнешняяКомпонента - экземпляр внешней компоненты
//	Сообщение - Строка - строка отладочного сообщения
//
Процедура ЗарегистрироватьОтладочноеСообщение(Очередь, Сообщение)
	
	Очередь.CallAsProc("WriteLog", 0, Сообщение);
	
КонецПроцедуры

//Процедура - установить соединение и зарегистрировать ошибку
//
//Параметры:
//	Сообщение - Строка - строка сообщения об ошибке
//
Процедура УстановитьСоединениеИЗарегистрироватьОшибку(Сообщение) Экспорт
	
	ИсходящаяОчередь = Обработки.сшпВызовыКомпоненты.Создать();     
	ИсходящаяОчередь.ИнициализироватьКомпоненту();  
	
	ИдАдаптера = сшпРаботаСКонстантами.ПолучитьИдАдаптера();
	
	ИсходящаяОчередь.CallAsProc("InitDataSender", ИдАдаптера + "_datareon_server", НомерСеансаИнформационнойБазы());
	
	ЗарегистрироватьОшибку(ИсходящаяОчередь, Сообщение);
	
	ИсходящаяОчередь.CallAsProc("Stop");
	
КонецПроцедуры

//Процедура - установить соединение и зарегистрировать предупреждение
//
//Параметры:
//	Сообщение - строка - строка сообщения о предупреждении
//
Процедура УстановитьСоединениеИЗарегистрироватьПредупреждение(Сообщение) Экспорт
	
	ИсходящаяОчередь = Обработки.сшпВызовыКомпоненты.Создать();     
	ИсходящаяОчередь.ИнициализироватьКомпоненту(); 

	ИдАдаптера = сшпРаботаСКонстантами.ПолучитьИдАдаптера();
	
	ИсходящаяОчередь.CallAsProc("InitDataSender", ИдАдаптера + "_datareon_server", НомерСеансаИнформационнойБазы());
	
	ЗарегистрироватьПредупреждение(ИсходящаяОчередь, Сообщение);
	
	ИсходящаяОчередь.CallAsProc("Stop");
	
КонецПроцедуры

//Процедура - установить соединение и зарегистрировать информационное сообщение
//
//Параметры:
//	Сообщение - Строка - строка информационного сообщения
//
Процедура УстановитьСоединениеИЗарегистрироватьИнформационноеСообщение(Сообщение) Экспорт
	
	ИсходящаяОчередь = Обработки.сшпВызовыКомпоненты.Создать();     
	ИсходящаяОчередь.ИнициализироватьКомпоненту(); 
	
	ИдАдаптера = сшпРаботаСКонстантами.ПолучитьИдАдаптера();
	
	ИсходящаяОчередь.CallAsProc("InitDataSender", ИдАдаптера + "_datareon_server", НомерСеансаИнформационнойБазы());
	
	ЗарегистрироватьИнформационноеСообщение(ИсходящаяОчередь, Сообщение);
	
	ИсходящаяОчередь.CallAsProc("Stop");
	
КонецПроцедуры

//Процедура - установить соединение и зарегистрировать отладочное сообщение
//
//Параметры:
//	Сообщение - Строка - строка отладочного сообщения
//
Процедура УстановитьСоединениеИЗарегистрироватьОтладочноеСообщение(Сообщение) Экспорт
	
	ИсходящаяОчередь = Обработки.сшпВызовыКомпоненты.Создать();     
	ИсходящаяОчередь.ИнициализироватьКомпоненту(); 
	
	ИдАдаптера = сшпРаботаСКонстантами.ПолучитьИдАдаптера();
	
	ИсходящаяОчередь.CallAsProc("InitDataSender", ИдАдаптера + "_datareon_server", НомерСеансаИнформационнойБазы());
	
	ЗарегистрироватьОтладочноеСообщение(ИсходящаяОчередь, Сообщение);
	
	ИсходящаяОчередь.CallAsProc("Stop");
	
КонецПроцедуры

#КонецОбласти

#Область ВспомогательныеМетоды

//Функция - Проверить разрешение на работу
//
//Параметры:
//	ВерсияПараметровПодсистемы - УникальныйИдентификатор - версия параметров подсистемы
//	ТипОчереди - Перечисление.сшпТипыОчередей - тип очереди
//  ИндексПотока - Число - индекс потока
//
//Возвращаемое значение:
//  Булево - результат проверки
//
Функция ПроверитьРазрешениеНаРаботу(ВерсияПараметровПодсистемы, ТипОчереди, ИндексПотока = 0)
		
	Если КонфигурацияБазыДанныхИзмененаДинамически() Тогда
		
		Возврат Ложь;
		
	КонецЕсли;
		
	Если сшпФункциональныеОпции.ОтключитьСоединение() Тогда
		
		Возврат Ложь;
		
	КонецЕсли;
		
	Если сшпОбщегоНазначения.ПараметрыПодсистемыОбновлены(ВерсияПараметровПодсистемы) Тогда 
		
		Если Константы.сшпИДАдаптера.Получить() <> сшпРаботаСКонстантами.ПолучитьИдАдаптера() Тогда 
			
			//изменилось имя канала, нужно завершить этот сеанс и начать новый
			Возврат Ложь;
			
		КонецЕсли;
		
		ОбновитьПовторноИспользуемыеЗначения();
		
		Если Не сшпФункциональныеОпции.ИспользоватьСШП() Тогда
			
			Возврат Ложь;
			
		КонецЕсли;
		
		Если сшпФункциональныеОпции.ТипИспользуемогоКоннектораESB() <> Перечисления.сшпТипыКоннекторовESB.Pipe Тогда 
			
			Возврат Ложь;
			
		КонецЕсли;
		
		Если ТипОчереди <> Перечисления.сшпТипыОчередей.Системная И сшпФункциональныеОпции.ОтключитьПотоки() Тогда 
			
			Возврат Ложь;
			
		КонецЕсли;
		
		Если ТипОчереди = Перечисления.сшпТипыОчередей.Входящая 
			И сшпРаботаСКонстантами.ПолучитьЗначениеКонстанты("сшпМаксимальноеКоличествоПотоковОбработкиВходящих") < ИндексПотока Тогда
			
			Возврат Ложь;
			
		КонецЕсли;
		
		Если ТипОчереди = Перечисления.сшпТипыОчередей.Исходящая  
			И сшпРаботаСКонстантами.ПолучитьЗначениеКонстанты("сшпМаксимальноеКоличествоПотоковОбработкиИсходящих") < ИндексПотока Тогда
			
			Возврат Ложь;
			
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат Истина;
	
КонецФункции

#КонецОбласти

#Область РаботаСФункциями

Функция ВыполнитьФункцию(ИмяФункции, dt_Параметр1 = Неопределено, dt_Параметр2 = Неопределено,
	dt_Параметр3 = Неопределено, dt_Параметр4 = Неопределено, dt_Параметр5 = Неопределено, dt_Параметр6 = Неопределено,
	dt_Параметр7 = Неопределено, dt_Параметр8 = Неопределено, dt_Параметр9 = Неопределено, dt_Параметр10 = Неопределено)

	Возврат сшпОбщегоНазначения.ВыполнитьФункцию(ИмяФункции, dt_Параметр1, dt_Параметр2, dt_Параметр3, dt_Параметр4,
		dt_Параметр5, dt_Параметр6, dt_Параметр7, dt_Параметр8, dt_Параметр9, dt_Параметр10);

КонецФункции

#КонецОбласти
