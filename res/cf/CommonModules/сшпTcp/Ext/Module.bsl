#Область Логирование

//Процедура Зарегистрировать ошибку
//
//Параметры:
//	Очередь - ВнешняяКомпонента - экземпляр внешней компоненты
//	Сообщение - Строка - строка сообщения об ошибке
//
Процедура ЗарегистрироватьОшибку(Очередь, Сообщение)
	
	Очередь.CallAsFunc("WriteTcpLog", 3, Сообщение);
	
КонецПроцедуры

//Процедура Зарегистрировать предупреждение
//
//Параметры:
//	Очередь - ВнешняяКомпонента - экземпляр внешней компоненты
//	Сообщение - Строка - строка сообщения о предупреждении
//
Процедура ЗарегистрироватьПредупреждение(Очередь, Сообщение)
	
	Очередь.CallAsFunc("WriteTcpLog", 2, Сообщение);

КонецПроцедуры

//Процедура Зарегистрировать информационное сообщение
//
//Параметры:
//	Очередь - ВнешняяКомпонента - экземпляр внешней компоненты
//	Сообщение - Строка - строка информационного сообщения
//
Процедура ЗарегистрироватьИнформационноеСообщение(Очередь, Сообщение)
	
	Очередь.CallAsFunc("WriteTcpLog", 1, Сообщение);
	
КонецПроцедуры

//Процедура Зарегистрировать отладочное сообщение
//
//Параметры:
//	Очередь - ВнешняяКомпонента - экземпляр внешней компоненты
//	Сообщение - Строка - строка отладочного сообщения
//
Процедура ЗарегистрироватьОтладочноеСообщение(Очередь, Сообщение)
	
	Очередь.CallAsFunc("WriteTcpLog", 0, Сообщение);
	
КонецПроцедуры

//Процедура - установить соединение и зарегистрировать ошибку
//
//Параметры:
//	Сообщение - Строка - строка сообщения об ошибке
//
Процедура УстановитьСоединениеИЗарегистрироватьОшибку(Сообщение) Экспорт
	
	ИсходящаяОчередь = Обработки.сшпВызовыКомпоненты.Создать();
	ИсходящаяОчередь.ИнициализироватьКомпоненту();
	
	СтруктураСоединения = ПолучитьСтруктуруСоединения();
	СтруктураСоединения.Компонента = ИсходящаяОчередь;
	СтруктураСоединения.Сервисный = 1;
	СтруктураСоединения.Режим = 1;
	
	Если УстановитьСоединение(СтруктураСоединения) Тогда
	
		ЗарегистрироватьОшибку(ИсходящаяОчередь, Сообщение);
		
		ПрерватьСоединение(ИсходящаяОчередь);
				
	конецЕсли;
	
КонецПроцедуры

//Процедура - установить соединение и зарегистрировать предупреждение
//
//Параметры:
//	Сообщение - Строка - строка сообщения о предупреждении
//
Процедура УстановитьСоединениеИЗарегистрироватьПредупреждение(Сообщение) Экспорт
	
	ИсходящаяОчередь = Обработки.сшпВызовыКомпоненты.Создать();
	ИсходящаяОчередь.ИнициализироватьКомпоненту();
	
	СтруктураСоединения = ПолучитьСтруктуруСоединения();
	СтруктураСоединения.Компонента = ИсходящаяОчередь;
	СтруктураСоединения.Сервисный = 1;
	СтруктураСоединения.Режим = 1;
	
	Если УстановитьСоединение(СтруктураСоединения) Тогда
	
		ЗарегистрироватьПредупреждение(ИсходящаяОчередь, Сообщение);
		
		ПрерватьСоединение(ИсходящаяОчередь);
		
	КонецЕсли;
	
КонецПроцедуры                          

//Процедура - установить соединение и зарегистрировать информационное сообщение
//
//Параметры:
//	Сообщение - Строка - строка информационного сообщения
//
Процедура УстановитьСоединениеИЗарегистрироватьИнформационноеСообщение(Сообщение) Экспорт
	
	ИсходящаяОчередь = Обработки.сшпВызовыКомпоненты.Создать();
	ИсходящаяОчередь.ИнициализироватьКомпоненту();

	СтруктураСоединения = ПолучитьСтруктуруСоединения();
	СтруктураСоединения.Компонента = ИсходящаяОчередь;
	СтруктураСоединения.Сервисный = 1;
	СтруктураСоединения.Режим = 1;
	
	Если УстановитьСоединение(СтруктураСоединения) Тогда
	
		ЗарегистрироватьИнформационноеСообщение(ИсходящаяОчередь, Сообщение);
		
		ПрерватьСоединение(ИсходящаяОчередь);
	
	КонецЕсли;
	
КонецПроцедуры

//Процедура - установить соединение и зарегистрировать отладочное сообщение
//
//Параметры:
//	Сообщение - Строка - строка отладочного сообщения
//
Процедура УстановитьСоединениеИЗарегистрироватьОтладочноеСообщение(Сообщение) Экспорт
	
	ИсходящаяОчередь = Обработки.сшпВызовыКомпоненты.Создать();
	ИсходящаяОчередь.ИнициализироватьКомпоненту();
	
	СтруктураСоединения = ПолучитьСтруктуруСоединения();
	СтруктураСоединения.Компонента = ИсходящаяОчередь;
	СтруктураСоединения.Сервисный = 1;
	СтруктураСоединения.Режим = 1;
	
	Если УстановитьСоединение(СтруктураСоединения) Тогда
	
		ЗарегистрироватьОтладочноеСообщение(ИсходящаяОчередь, Сообщение);
		
		ПрерватьСоединение(ИсходящаяОчередь);
		
	КонецЕсли;
	
КонецПроцедуры

#КонецОбласти

#Область Служебные

//Функция - Помошник установки соединения с определенным режимом
//
//Параметры:
//	СтруктураСоединения - Структура - Структура параметров соединения
//
Функция УстановитьСоединение(СтруктураСоединения) Экспорт
	
	КлючАдаптера = сшпРаботаСКонстантами.ПолучитьЗначениеКонстанты("сшпКлючTcp");
	АдресСервера = сшпРаботаСКонстантами.ПолучитьЗначениеКонстанты("сшпАдресTcpСервера");
	ПортСервера = сшпРаботаСКонстантами.ПолучитьЗначениеКонстанты("сшпПортTcpСервера");
	
	ДанныеСтрокиСоединения = сшпРаботаСоСтроками._СтрРазделить(СтрокаСоединенияИнформационнойБазы(), ";");
	
	Если Не ДанныеСтрокиСоединения.Количество() = 3 Тогда
		
		ЗаписьЖурналаРегистрации("Datareon.Ошибка получения строки соединения", УровеньЖурналаРегистрации.Ошибка, , , "Работа с файловыми информационными базами не поддерживается");
		Возврат Ложь;
		
	КонецЕсли;
	
	ИмяБазы = Сред(ДанныеСтрокиСоединения[1], 6, СтрДлина(ДанныеСтрокиСоединения[1]) - 6);	

	Попытка
		
		Если СтруктураСоединения.Компонента.CallAsFunc("ConnectToServer", АдресСервера, ПортСервера) = 0 Тогда
			
			результатОтправки = СтруктураСоединения.Компонента.CallAsFunc(
				"SendTcpInitMessage", ИмяБазы, КлючАдаптера, СтруктураСоединения.Сервисный, СтруктураСоединения.Режим
				);
						
			Если Не результатОтправки = 0 Тогда
				
				ТекстОшибки = "При отправке авторизации на сервере произошла ошибка";			
				ЗаписьЖурналаРегистрации("Datareon. Подключение к tcp серверу", УровеньЖурналаРегистрации.Ошибка, , , ТекстОшибки);
				
				Возврат Ложь;
				
			КонецЕсли;
			
			ПолученноеИмяБазы = "";
			ПолученныйКлюч = "";  
			статусСоединения = СтруктураСоединения.Компонента.CallAsFunc(
				"RecvTcpInitResponseMessage", ПолученноеИмяБазы, ПолученныйКлюч
			);
			
			Если статусСоединения = 0 Тогда
				
				Если СтруктураСоединения.Режим = 0 Тогда
					
					СтруктураСоединения.Компонента.CallAsFunc("InitTcpRead", НомерСеансаИнформационнойБазы());
					
				КонецЕсли;
				
				Возврат Истина;
					
			ИначеЕсли статусСоединения = -1 Тогда
				
				ТекстОшибки = "Авторизация на сервере не пройдена, ответ не получен!";
			
				ЗаписьЖурналаРегистрации("Datareon. Подключение к tcp серверу", УровеньЖурналаРегистрации.Ошибка, , , ТекстОшибки);
				
				Возврат Ложь;
				
			ИначеЕсли статусСоединения = 1 Тогда
				
				ТекстОшибки = "Авторизация на сервере не пройдена, не соответствует ключ " + ПолученныйКлюч + "!";				
				ЗаписьЖурналаРегистрации("Datareon. Подключение к tcp серверу", УровеньЖурналаРегистрации.Ошибка, , , ТекстОшибки);
				
				Возврат Ложь;
				
			ИначеЕсли статусСоединения = 2 Тогда
				
				ТекстОшибки = "Авторизация на сервере не пройдена, не соответствует имя базы " + ПолученноеИмяБазы + "!";				
				ЗаписьЖурналаРегистрации("Datareon. Подключение к tcp серверу", УровеньЖурналаРегистрации.Ошибка, , , ТекстОшибки);
				
				Возврат Ложь;
			
			КонецЕсли;
			
		Иначе
			
			ТекстОшибки = "При подключении к серверу " + АдресСервера + ":" + ПортСервера + " произошла ошибка";			
			ЗаписьЖурналаРегистрации("Datareon. Подключение к tcp серверу", УровеньЖурналаРегистрации.Ошибка, , , ТекстОшибки);
			
			Возврат Ложь;
			
		КонецЕсли;
		
	Исключение
		
		ТекстОшибки = "При подключении к серверу " + АдресСервера + ":" + ПортСервера + " произошла ошибка: " + Символы.ПС + ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		ЗапуститьПотокСЗадержкойАссинхронно("сшпTcp.ПолучениеСлужебныхСообщений", "сшпTcp.ПолучениеСлужебныхСообщений");
		ЗаписьЖурналаРегистрации("Datareon. Подключение к tcp серверу", УровеньЖурналаРегистрации.Ошибка, , , ТекстОшибки);
		                                           
		Возврат Ложь;
		
	КонецПопытки;
	
КонецФункции

//Процедура - Прерывает соединение с сервером
//
//Параметры:
//	Компонента - ВнешняяКомпонента - экземпляр внешней компоненты
//
Процедура ПрерватьСоединение(Компонента)
	
	Компонента.CallAsFunc("StopTcp");
	
	Компонента = Неопределено;
	
КонецПроцедуры

//Функция - проверяет соединение с сервером
//
//Параметры:
//	Компонента - ВнешняяКомпонента - экземпляр внешней компоненты
//
Функция ПроверитьСоединение(Компонента)
	
	Если Компонента = Неопределено Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Возврат ?(Компонента.CallAsFunc("CheckTcpConnection") = 0, Истина, Ложь);
	
КонецФункции

//Функция - получить структуру соединения
//
//Возвращаемое значение:
// Структура - Структура tcp соединения
//
Функция ПолучитьСтруктуруСоединения()
	
	СтруктураСоединения = Новый Структура;
	СтруктураСоединения.Вставить("Компонента", Неопределено);
	СтруктураСоединения.Вставить("Сервисный", 0);
	СтруктураСоединения.Вставить("Режим", 0);
	
	Возврат СтруктураСоединения;
	
КонецФункции

//Функция - восстановить соединение
//
//Параметры:
// СтруктураСоединения - Структура - Структура tcp соединения (См. сшпTcp.ПолучитьСтруктуруСоединения())
// 
//Возвращаемое значение:
// Булево - Результат восстановления
//
Функция ВосстановитьСоединение(СтруктураСоединения)
	
	КоличествоПопыток = 3;
	
	Пока КоличествоПопыток > 0 И Не сшпФункциональныеОпции.ОтключитьСоединение() Цикл
		                                                  
		СтруктураСоединения.Компонента.CallAsProc("Sleep", 1000);
		
		Если УстановитьСоединение(СтруктураСоединения) Тогда
			
			Возврат Истина;	
		
		КонецЕсли;
		
		КоличествоПопыток = КоличествоПопыток - 1;
		
	КонецЦикла;
	
	Возврат Ложь;
	
КонецФункции

//Функция - получить количество запущенных потоков
//
//Возвращаемое значение:
// Число - Количество фоновых заданий "ПолучениеТранспортныхСообщений"
//
Функция ПолучитьКоличествоЗапущенныхПотоков()
	
	СтруктураОтбора = Новый Структура;
	СтруктураОтбора.Вставить("Состояние", СостояниеФоновогоЗадания.Активно);
	МассивРезультатов = ФоновыеЗадания.ПолучитьФоновыеЗадания(СтруктураОтбора);
	
	Счетчик = 0;
	
	Для Сч = 0 По МассивРезультатов.Количество()-1 Цикл
		
		Если Найти(МассивРезультатов[Сч].Наименование, "сшпTcp.") > 0 Тогда
			
			Если Найти(МассивРезультатов[Сч].Наименование, "ПолучениеТранспортныхСообщений") > 0 Тогда
				
				Счетчик = Счетчик + 2;
				
			Иначе
				
				Счетчик = Счетчик + 1;	
				
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Счетчик;
	
КонецФункции

//Процедура - проверить обрыв соединения
//
//Параметры:
// КоличествоПотоковEsb - Число - Количество потоков на tcp сервере ESB
//
Процедура ПроверитьОбрывСоединения(КоличествоПотоковEsb)
	
	КоличествоПотоков1С = ПолучитьКоличествоЗапущенныхПотоков() - 1;
	
	Если КоличествоПотоков1С > 0 И 
		КоличествоПотоковEsb < КоличествоПотоков1С Тогда
				
		сшпРаботаСКонстантами.УстановитьЗначениеКонстанты("сшпОтключитьСоединение", Истина);
		сшпОбщегоНазначения.Ожидание(10);

	КонецЕсли;
	
КонецПроцедуры

// Отправляет аварийный запрос в ESB для уточнения статуса
// 
// Возвращаемое значение:
// 	Булево - Результат попытки
//
Функция АварийныйЗапрос()
	
	ЗапуститьПоток("сшпTcp.ПолучениеСлужебныхСообщений", "сшпTcp.ПолучениеСлужебныхСообщений");
	
	РезультатОбработки = сшпОбщегоНазначения.СформироватьСтруктуруПакета("EMM","Esb-EmergencyRequest");
	
	Возврат сшпВзаимодействиеСАдаптером.ОтправитьСистемноеСообщениеБезОчереди(РезультатОбработки);

КонецФункции

// Сверка ключей
// 
// Параметры:
// 	КлючАдаптера - Строка - Ключ адаптера
//
Процедура СверкаКлючей(КлючАдаптера)
	
	xdtoТип = ФабрикаXDTO.Тип("http://esb.axelot.ru", "Message");
	ПакетXDTO = сшпОбщегоНазначения.ПолучитьОбъектXDTO(Перечисления.сшпФорматыСообщений.XML, КлючАдаптера, xdtoТип);
	
	КлючБД = Константы.сшпКлючTcp.Получить();
	Если Не КлючБД = СокрЛП(ПакетXDTO.Body) Тогда
		
		ТекстСообщения = "Аварийным запросом был получен не корректный ключ, потоки обработки данных будут остановлены до получения корректной конфигурации.";
		ЗарегистрироватьРезультатЗавершенияЗадания("Datareon.Аварийный запрос", УровеньЖурналаРегистрации.Ошибка, ТекстСообщения);
		
		сшпРаботаСКонстантами.УстановитьЗначениеКонстанты("сшпОтключитьСоединение", Истина);
		
	Иначе
		
		сшпРаботаСКонстантами.УстановитьЗначениеКонстанты("сшпКоличествоНеудачныхПопытокTcp", 0);
		
		ТекстСообщения = "Аварийный запрос подтвержден, ключ соответствует!";
		ЗарегистрироватьРезультатЗавершенияЗадания("Datareon.Аварийный запрос", УровеньЖурналаРегистрации.Информация, ТекстСообщения);
		
		ЗапуститьПоток("сшпОбслуживаниеОчередей.ОчисткаОчередейСообщений", "сшпОбслуживаниеОчередей.ОчисткаОчередейСообщений");
		ЗапуститьПоток("сшпTcp.ОбработатьКвитанции", "сшпTcp.ОбработатьКвитанции");
		ЗапуститьПотокОбменаТранспортнымиСообщениями();
		
	КонецЕсли;
	
КонецПроцедуры

#КонецОбласти

#Область ЗапускОбработчиков

//Процедура - Запустить обработчкики
//
Процедура ЗапуститьОбработчики() Экспорт
	
	Если Не сшпФункциональныеОпции.ИспользоватьСШП() Тогда 
		
		Возврат;
		
	КонецЕсли;
	
	ИмяСобытияЖР = СобытиеИнициализацииПодключенияКАдаптеру();
	
	ЗаписьЖурналаРегистрации(ИмяСобытияЖР, УровеньЖурналаРегистрации.Информация, , , ИмяСобытияЖР);
	
	Если Не сшпОбщегоНазначения.ПроверитьЭкземплярИнформационнойБазы() Тогда
		
		ЗаписьЖурналаРегистрации(ИмяСобытияЖР, УровеньЖурналаРегистрации.Ошибка,,, "Рассинхронизация идентификаторов информационной базы");
		
		Возврат;
		
	КонецЕсли;
	
	Попытка
		
		АдресИБ = сшпОбщегоНазначения.ПолучитьСтруктуруАдресаИБ();
		
	Исключение
		
		ЗаписьЖурналаРегистрации(ИмяСобытияЖР, УровеньЖурналаРегистрации.Ошибка, , , КраткоеПредставлениеОшибки(ИнформацияОбОшибке()));
		
		Возврат;
		
	КонецПопытки;	
	
	Компонента = Обработки.сшпВызовыКомпоненты.Создать();
	Компонента.ИнициализироватьКомпоненту();
	
	Если Компонента = Неопределено Тогда
		
		Возврат;
		
	КонецЕсли;
	
	АдресаNM = ПолучитьАдресаМенеджеровУзловИзИБ();
	
	ВерсияАдресов         = АдресаNM.Версия;
	АдресаМенеджеровУзлов = АдресаNM.Адреса;
	
	ПолучитьАдресаМенеджеровУзловИзESB(Компонента, АдресаМенеджеровУзлов);
	
	Если АдресаМенеджеровУзлов.Количество() = 0 Тогда
		
		АдресTcpСервера = Константы.сшпАдресTcpСервера.Получить();	
		
		Если ЗначениеЗаполнено(АдресTcpСервера) Тогда
			
			сшпОбщегоНазначения.ДобавитьАдресМенеджераУзла(АдресаМенеджеровУзлов, АдресTcpСервера, 9999); 
			
		КонецЕсли;	
		
	КонецЕсли;
	
	СостояниеАдаптера = ПолучитьСостояниеАдаптера(Компонента, АдресаМенеджеровУзлов, АдресИБ);
	
	КодСостояния      = СостояниеАдаптера.Состояние;
	ИмяБазы           = СостояниеАдаптера.ИмяБазы;
	ИмяАдаптера       = СостояниеАдаптера.ИмяАдаптера;
	АдресСервера      = СостояниеАдаптера.АдресСервера;
	Порт              = СостояниеАдаптера.ПортСервера;
	Ключ              = СостояниеАдаптера.Ключ;
	КоличествоПотоков = СостояниеАдаптера.КоличествоПотоков;
	ИмяБазыЭталон     = АдресИБ.ИмяБазы;
		
	сшпОбщегоНазначения.СохранитьАдресаМенеджеровУзлов(АдресаМенеджеровУзлов, ВерсияАдресов);
	
	Компонента = Неопределено;
	
	Если КодСостояния = 0 Тогда
				
		ОбнулитьСчетчикОтключенияПотоков();
		
		ПроверитьОбрывСоединения(Число(КоличествоПотоков));
		
		сшпРаботаСКонстантами.УстановитьЗначениеКонстанты("сшпОтключитьСоединение", Ложь);
		
		Если Не НРег(ИмяБазы) = НРег(ИмяБазыЭталон) Тогда
			
			ТекстСообщения = "Полученные настройки не корректны. Имя базы в адаптере: " + ИмяБазы + ", Реальное имя базы: " + ИмяБазыЭталон;
			ЗарегистрироватьРезультатЗавершенияЗадания(ИмяСобытияЖР, УровеньЖурналаРегистрации.Предупреждение, ТекстСообщения);		
			
			Возврат;
			
		КонецЕсли;
		
		СтарыйАдресСервера = Константы.сшпАдресTcpСервера.Получить();
		
		Если Не НРег(АдресСервера) = НРег(СтарыйАдресСервера) И ЗначениеЗаполнено(СтарыйАдресСервера) Тогда
			сшпОбщегоНазначения.ЗарегистрироватьЗаписьВЖурнале(УровеньЖурналаРегистрации.Информация, "Datareon. Запуск обработчиков", "Был изменен адрес сервера с " + СтарыйАдресСервера + " на " + АдресСервера + ".");
		КонецЕсли;
		
		сшпОбщегоНазначения.УстановитьСвойстваАдаптераTcp(АдресСервера, Порт, ИмяАдаптера, Ключ);
		
		ЗапуститьПоток("сшпTcp.ПолучениеСлужебныхСообщений", "сшпTcp.ПолучениеСлужебныхСообщений");
		ЗапуститьПоток("сшпОбслуживаниеОчередей.ОчисткаОчередейСообщений", "сшпОбслуживаниеОчередей.ОчисткаОчередейСообщений");
		ЗапуститьПоток("сшпTcp.ОбработатьКвитанции", "сшпTcp.ОбработатьКвитанции");
		
		КомпонентаПауза = Обработки.сшпВызовыКомпоненты.Создать();
		КомпонентаПауза.ИнициализироватьКомпоненту();	
	
		КомпонентаПауза.CallAsProc("Sleep", 2000);
		
		КомпонентаПауза = Неопределено;
		
		ЗапуститьПотокОбменаТранспортнымиСообщениями();
		
	ИначеЕсли Не сшпФункциональныеОпции.ТипИспользуемогоКоннектораESB() = Перечисления.сшпТипыКоннекторовESB.Tcp Тогда 
	
		Возврат;
	
	ИначеЕсли (КодСостояния = 1) Тогда
		
		Если ОтключитьПотокиПоТаймауту() Тогда
		
			ТекстСообщения = "Не обнаружен адаптер для работы с текущей ИБ. Проверьте настройки адаптера. Имя сервера = " + АдресИБ.Адрес + ", Имя базы = " + ИмяБазыЭталон;
			ЗарегистрироватьРезультатЗавершенияЗадания(ИмяСобытияЖР, УровеньЖурналаРегистрации.Предупреждение, ТекстСообщения);
			
			сшпРаботаСКонстантами.УстановитьЗначениеКонстанты("сшпОтключитьСоединение", Истина);
		
		КонецЕсли;
		
	ИначеЕсли (КодСостояния = 2) Тогда
		
		ТекстСообщения = "Адаптер " + ИмяАдаптера + " остановлен. Передача данных остановлена.";
		ЗарегистрироватьРезультатЗавершенияЗадания(ИмяСобытияЖР, УровеньЖурналаРегистрации.Информация, ТекстСообщения);
		
		сшпРаботаСКонстантами.УстановитьЗначениеКонстанты("сшпОтключитьСоединение", Истина);
		
	ИначеЕсли (КодСостояния = 10) Тогда
		
		сшпРаботаСКонстантами.УстановитьЗначениеКонстанты("сшпОтключитьСоединение", Истина);
		
	Иначе
		
		ТекстСообщения = "Не удалось инициализировать подключение к адаптеру. Получено состояние адаптера " + КодСостояния;
		ЗарегистрироватьРезультатЗавершенияЗадания(ИмяСобытияЖР, УровеньЖурналаРегистрации.Ошибка, ТекстСообщения);
		
		Если ОтключитьПотокиПоТаймауту() Тогда

			ТекстСообщения = "Превышено количество неудачных попыток подключения по tcp, потоки обработки данных будут остановлены до получения корректной конфигурации.";
			ЗарегистрироватьРезультатЗавершенияЗадания(ИмяСобытияЖР, УровеньЖурналаРегистрации.Ошибка, ТекстСообщения);
			
			сшпРаботаСКонстантами.УстановитьЗначениеКонстанты("сшпОтключитьСоединение", Истина);
			
		КонецЕсли;
		
	КонецЕсли;  
	
КонецПроцедуры

//Процедура - получает с адреса менеджеров узлов из внешней компоненты 
//
//Параметры:
//	Компонента - ВнешняяКомпонента - Компонента для получения списка адресов
//	Адреса - ТаблицаЗначений - таблица с адресами менеджеров узлов
//
Процедура ПолучитьАдресаМенеджеровУзловИзESB(Компонента, Адреса)
	
	Компонента.CallAsFunc("StartListenConfig", 6000, 5555);
	
	Ответ = 0;
	Пока Не Ответ = 1 Цикл
		
		АдресNM = "";
		ПортNM  = "";
		
		Ответ = Компонента.CallAsFunc("GetAddressNmTcp", АдресNM, ПортNM);
		
		АдресNMОтвет = Строка(АдресNM);
		ПортNMОтвет = ПортNM;
		
		Если Ответ = 0 Тогда
			сшпОбщегоНазначения.ДобавитьАдресМенеджераУзла(Адреса, АдресNMОтвет, ПортNMОтвет);
		КонецЕсли;	
		
	КонецЦикла;
	
КонецПроцедуры

//Функция - Получить адреса менеджеров узлов, сохраненных в ИБ
//
//Возвращаемое значение:
//	ТаблицаЗначений - адреса менеджеров узлов
//
Функция ПолучитьАдресаМенеджеровУзловИзИБ()
	Возврат сшпОбщегоНазначения.ПолучитьАдресаМенеджеровУзлов();
КонецФункции	

//Функция - Получить конфигурацию адаптера
//
//Параметры:
//	Компонента - ВнешняяКомпонента - Компонента для получения конфигурации адаптера
//	АдресаМенеджеровУзлов - ТаблицаЗначений - таблица с адресами менеджеров узлов
//  АдресИБ - Структура - Строка соединения с информационной базой
//
//Возвращаемое значение:
//	Структура - структура конфигурации адаптера
//
Функция ПолучитьСостояниеАдаптера(Компонента, АдресаМенеджеровУзлов, АдресИБ)
	
	ИмяСобытияЖР = СобытиеИнициализацииПодключенияКАдаптеру();
	
	Состояния = Новый Соответствие;
	
	АдресаДляУдаления = Новый Массив;
	
	КоннекторНеTcp = Ложь;
	
	СписокОшибокПодключения = Новый СписокЗначений();
	СписокПредупрежденийПодключения = Новый СписокЗначений();
	
	Для Каждого АдресNM из АдресаМенеджеровУзлов Цикл
		ТекстОшибкиПодключения = "";
		
		РезультатПодключения = Компонента.CallAsFunc("ConnectToNm",
			АдресNM.Адрес, 
			АдресNM.Порт, 
			АдресИБ.ИмяБазы, 
			АдресИБ.Адрес,
			АдресИБ.Порт
		);
		
		Если Не РезультатПодключения = 0 Тогда
			ТекстОшибкиПодключения = Компонента.CallAsFunc("GetLastErrorMessage");
		Иначе
			ИмяБазы           = "";
			ИмяАдаптера       = "";
			АдресСервера      = "";
			ПортСервера       = "";
			Ключ              = "";
			ВремяНастроек     = "";
			КоличествоПотоков = "";
			
			Состояние = Компонента.CallAsFunc("RecvTcpConfigMessage",
				6000, 
				ИмяБазы, 
				ИмяАдаптера, 
				АдресСервера, 
				ПортСервера, 
				Ключ, 
				ВремяНастроек, 
				КоличествоПотоков
			);
			
			СостояниеАдаптера = НовоеСостояниеАдаптера();
			СостояниеАдаптера.Состояние         = Состояние;
			СостояниеАдаптера.ИмяБазы           = ИмяБазы;
			СостояниеАдаптера.ИмяАдаптера       = ИмяАдаптера;
			СостояниеАдаптера.АдресСервера      = АдресСервера;
			СостояниеАдаптера.ПортСервера       = ПортСервера;
			СостояниеАдаптера.Ключ              = Ключ;
			СостояниеАдаптера.ВремяНастроек     = ВремяНастроек;
			СостояниеАдаптера.КоличествоПотоков = КоличествоПотоков;
			
			ИменаБазСовпадают = ВРег(ИмяБазы) = ВРег(АдресИБ.ИмяБазы);
			
			Если Состояние = 0 И Не ИменаБазСовпадают Тогда
				ТекстОшибкиПодключения = "Полученные настройки не корректны. Имя базы в адаптере: " + ИмяБазы + ", Реальное имя базы: " + АдресИБ.ИмяБазы;
			ИначеЕсли Состояние = 0 И Состояния.Получить(Состояние) = Неопределено Тогда
				Состояния.Вставить(СостояниеАдаптера.Состояние, СостояниеАдаптера);
			ИначеЕсли Состояние = 0 Тогда
				Если НРег(Состояния[0].АдресСервера) = НРег(АдресСервера) Тогда
					ЗаписьЖурналаРегистрации(ИмяСобытияЖР, УровеньЖурналаРегистрации.Предупреждение,,, "Обнаружены дубликаты настроек адресов узлов Datareon, настройка: " + АдресNM.Адрес);
				Иначе
					ЗаписьЖурналаРегистрации(ИмяСобытияЖР, УровеньЖурналаРегистрации.Ошибка,,, "Получены дублирующие настройки с менеджера узла для базы " + ИмяБазы + ", текущий адрес сервера: " + Состояния[0].АдресСервера + ", получен: " + АдресСервера);
					СостояниеАдаптера = НовоеСостояниеАдаптера();
					СостояниеАдаптера.Состояние = 10;			
					Возврат СостояниеАдаптера;	
				КонецЕсли;								
			ИначеЕсли Состояние = 2 И ИменаБазСовпадают Тогда	
				Состояния.Вставить(СостояниеАдаптера.Состояние, СостояниеАдаптера);
			ИначеЕсли Состояние = 3 Тогда
				ТекстОшибкиПодключения = Компонента.CallAsFunc("GetLastErrorMessage");
			ИначеЕсли Состояние = 4 Тогда
				ПолноеИмяБазы = ПолучитьСтрокуСоединенияСИнформационнойБазойПоСтруктуреАдреса(АдресИБ);
				ТекстОшибкиПодключения = "Адаптер для базы " + ПолноеИмяБазы + " не найден.";	
			КонецЕсли;	
		КонецЕсли;
		
		Если ЗначениеЗаполнено(ТекстОшибкиПодключения) Тогда
			АдресNM.СчетчикПопытокПодключения = АдресNM.СчетчикПопытокПодключения + 1;
			
			ТипКоннектора = сшпФункциональныеОпции.ТипИспользуемогоКоннектораESB();
			
			ЗарегистрироватьОшибку = Ложь;
			Если Не ЗначениеЗаполнено(ТипКоннектора) Тогда
				Если АдресNM.СчетчикПопытокПодключения > 60 Тогда
					ЗарегистрироватьОшибку = Ложь;

					Если АдресNM.ДобавленоВручную = Ложь Тогда
						АдресаДляУдаления.Добавить(АдресNM);	
					Иначе 
						АдресNM.СчетчикПопытокПодключения = 0;	
					КонецЕсли;	
				Иначе
					ЗарегистрироватьОшибку = Ложь;
				КонецЕсли;
			ИначеЕсли ТипКоннектора <> Перечисления.сшпТипыКоннекторовESB.Tcp Тогда
				КоннекторНеTcp = Истина;
				Если АдресNM.СчетчикПопытокПодключения > 60 Тогда
					ЗарегистрироватьОшибку = Ложь;

					Если АдресNM.ДобавленоВручную = Ложь Тогда
						АдресаДляУдаления.Добавить(АдресNM);	
					Иначе 
						АдресNM.СчетчикПопытокПодключения = 0;	
					КонецЕсли;	
				Иначе
					ЗарегистрироватьОшибку = Ложь;
				КонецЕсли;	
			ИначеЕсли ТипКоннектора = Перечисления.сшпТипыКоннекторовESB.Tcp Тогда	
				Если АдресNM.СчетчикПопытокПодключения > 60 Тогда
					ЗарегистрироватьОшибку = Истина;
					Если АдресNM.ДобавленоВручную = Ложь 
						И ВРег(Константы.сшпАдресTcpСервера.Получить()) <> ВРег(АдресNM.Адрес) Тогда
						АдресаДляУдаления.Добавить(АдресNM);	
					Иначе 
						АдресNM.СчетчикПопытокПодключения = 0;	
					КонецЕсли;	
				Иначе 
					ЗарегистрироватьОшибку = Ложь;
				КонецЕсли;	
			КонецЕсли;
			
			ТекстСообщения = "Ошибка подключения к менеджеру узла по адресу " + АдресNM.Адрес + ":" + АдресNM.Порт + ". " + ТекстОшибкиПодключения;
			Если ЗарегистрироватьОшибку Тогда
				СписокОшибокПодключения.Добавить(ТекстСообщения);
			Иначе 
				СписокПредупрежденийПодключения.Добавить(ТекстСообщения);
			КонецЕсли;	
		КонецЕсли;
	КонецЦикла;	
	
	Для Каждого АдресNM Из АдресаДляУдаления Цикл
		АдресаМенеджеровУзлов.Удалить(АдресNM);
	КонецЦикла;	
	
	// Получаем конфигурацию включенного адаптера.
	СостояниеАдаптера = Состояния.Получить(0);
	
	ИспользоватьПримечание = Ложь;
	
	Если СостояниеАдаптера = Неопределено Тогда
		
		// Получаем конфигурацию выключенного адаптера.
		СостояниеАдаптера = Состояния.Получить(2);
				
	КонецЕсли;
	
	ИспользоватьПримечание = Не СостояниеАдаптера = Неопределено ИЛИ КоннекторНеTcp;
	
	Если ИспользоватьПримечание Тогда
		
		СообщениеВЖурнал = "";
		
		Для Каждого СтрокаСпискаОшибок Из СписокОшибокПодключения Цикл
			СообщениеВЖурнал = СообщениеВЖурнал + СтрокаСпискаОшибок + Символы.ПС;
		КонецЦикла;
		
		Для Каждого СтрокаСпискаПредупреждения Из СписокПредупрежденийПодключения Цикл
			СообщениеВЖурнал = СообщениеВЖурнал + СтрокаСпискаПредупреждения + Символы.ПС;
		КонецЦикла;
		
		Если ЗначениеЗаполнено(СообщениеВЖурнал) Тогда
			ЗаписьЖурналаРегистрации(ИмяСобытияЖР, УровеньЖурналаРегистрации.Примечание,,, СообщениеВЖурнал);
		КонецЕсли;
		
	Иначе

		СообщениеВЖурнал = "";
		
		Для Каждого СтрокаСпискаОшибок Из СписокОшибокПодключения Цикл
			СообщениеВЖурнал = СообщениеВЖурнал + СтрокаСпискаОшибок + Символы.ПС;
		КонецЦикла;
		
		Если ЗначениеЗаполнено(СообщениеВЖурнал) Тогда
			ЗаписьЖурналаРегистрации(ИмяСобытияЖР, УровеньЖурналаРегистрации.Ошибка,,, СообщениеВЖурнал);
		КонецЕсли;
		
		СообщениеВЖурнал = "";
		
		Для Каждого СтрокаСпискаПредупреждения Из СписокПредупрежденийПодключения Цикл
			СообщениеВЖурнал = СообщениеВЖурнал + СтрокаСпискаПредупреждения + Символы.ПС;
		КонецЦикла;
		
		Если ЗначениеЗаполнено(СообщениеВЖурнал) Тогда
			ЗаписьЖурналаРегистрации(ИмяСобытияЖР, УровеньЖурналаРегистрации.Предупреждение,,, СообщениеВЖурнал);
		КонецЕсли;
			
	КонецЕсли;
	
	Если СостояниеАдаптера = Неопределено Тогда
		
		// Формируем пустую конфигурацию.
		СостояниеАдаптера = НовоеСостояниеАдаптера();
		СостояниеАдаптера.Состояние = 1;
		
	КонецЕсли;	
	
	Возврат СостояниеАдаптера;
	
КонецФункции	

//Функция - Получить новое состояние адаптера
//
//Возвращаемое значение:
//	Структура - структура состояния адаптера
//
Функция НовоеСостояниеАдаптера()
	Состояние = Новый Структура;
	Состояние.Вставить("Состояние");
	Состояние.Вставить("ИмяБазы");
	Состояние.Вставить("ИмяАдаптера");
	Состояние.Вставить("АдресСервера");
	Состояние.Вставить("ПортСервера");
	Состояние.Вставить("Ключ");
	Состояние.Вставить("ВремяНастроек");
	Состояние.Вставить("КоличествоПотоков");
	
	Возврат Состояние
КонецФункции	

//Функция - Получить имя события инициалиазции подключения к адаптеру для журнала регистрации
//
//Возвращаемое значение:
//	Строка - имя события для журнала регистрации
//
Функция СобытиеИнициализацииПодключенияКАдаптеру()
	Возврат "Datareon.Инициация подключения к адаптеру TCP";	
КонецФункции	

//Процедура - Зарегистрировать результат завершения задания
//
//Параметры:
//	ИмяСобытияЖР - Строка - Имя события
//	Уровень - УровеньЖурналаРегистрации - Уровень важности события
//	ТекстСообщения - Строка - Произвольная строка комментария по событию
//
Процедура ЗарегистрироватьРезультатЗавершенияЗадания(ИмяСобытияЖР, Уровень, ТекстСообщения)
	            
	ЗаписьЖурналаРегистрации(ИмяСобытияЖР, Уровень,,, ТекстСообщения);
	
	Сообщение = Новый СообщениеПользователю();
	Сообщение.Текст = ТекстСообщения;
	Сообщение.Сообщить();
	
КонецПроцедуры

//Процедура - Запустить поток обмена транспортными сообщениями
//
Процедура ЗапуститьПотокОбменаТранспортнымиСообщениями()
	
	Если Не сшпФункциональныеОпции.ОтключитьПотоки() И Не сшпФункциональныеОпции.ОтключитьСоединение() Тогда
				
		МаксимумПотоковВходящих = сшпРаботаСКонстантами.ПолучитьЗначениеКонстанты("сшпМаксимальноеКоличествоПотоковОбработкиВходящих");
		МаксимумПотоковИсходящих = сшпРаботаСКонстантами.ПолучитьЗначениеКонстанты("сшпМаксимальноеКоличествоПотоковОбработкиИсходящих");
		
		Если МаксимумПотоковВходящих = 0 Или 
			МаксимумПотоковИсходящих = 0 Тогда			
			Возврат;			
		КонецЕсли;
				
		//Входящий поток
		МассивПараметров = Новый Массив;
		МассивПараметров.Добавить();
		
		Для Индекс = 1 По МаксимумПотоковВходящих Цикл
						
			МассивПараметров[0] = Индекс;
			ЗапуститьПоток("сшпTcp.ПолучениеТранспортныхСообщений_" + Формат(Индекс, "ЧН=0; ЧГ=0"), "сшпTcp.ПолучениеТранспортныхСообщений", МассивПараметров);
			
			сшпОбщегоНазначения.Ожидание(1);
			
		КонецЦикла;
		
		//Исходящий поток
		ЗапуститьПоток("сшпTcp.ОбработкаОчередиИсходящихСообщений", "сшпTcp.ОбработкаОчередиИсходящихСообщений");
		
		МассивПараметров = Новый Массив;
		МассивПараметров.Добавить();
		
		Для Индекс = 1 По МаксимумПотоковИсходящих Цикл
			
			сшпОбщегоНазначения.Ожидание(1);
			
			МассивПараметров[0] = Индекс;
			ЗапуститьПоток("сшпTcp.ПередачаТранспортныхСообщений_" + Формат(Индекс, "ЧН=0; ЧГ=0"), "сшпTcp.ПередачаТранспортныхСообщений", МассивПараметров);
			
		КонецЦикла;
		
	КонецЕсли;
	
КонецПроцедуры

//Процедура - запускает поток с ожиданием, который после паузы запускает указанный в параметрах поток
//
//Параметры:
//	ИмяМетода - Строка - имя вызываемого метода
//	ПутьКМетоду - Строка - имя процедуры
//	Параметры - Массив - массив параметров
//	Пауза - Число - количество секунд ожидания перед запуском
//
Процедура ЗапуститьПотокСЗадержкойАссинхронно(ИмяМетода, ПутьКМетоду, Параметры = Неопределено, Пауза = 1) Экспорт
	
	МассивПараметров = Новый Массив;
	МассивПараметров.Добавить(ИмяМетода);
	МассивПараметров.Добавить(ПутьКМетоду);
	МассивПараметров.Добавить(Параметры);
	МассивПараметров.Добавить(Пауза);
	
	ФоновыеЗадания.Выполнить("сшпTcp.ЗапуститьПотокСЗадержкой", массивПараметров, , "сшпTcp.ЗапуститьПотокСЗадержкой: " + ИмяМетода);
	
КонецПроцедуры

//Процедура - запускает поток с ожиданием
//
//Параметры:
//	ИмяМетода - Строка - имя вызываемого метода
//	ПутьКМетоду - Строка - имя процедуры
//	Параметры - Массив - массив параметров
//	Пауза - Число - количество секунд ожидания перед запуском
//
Процедура ЗапуститьПотокСЗадержкой(ИмяМетода, ПутьКМетоду, Параметры = Неопределено, Пауза = 1) Экспорт
	
	сшпОбщегоНазначения.Ожидание(Пауза);
	
	ЗапуститьПоток(ИмяМетода, ПутьКМетоду, Параметры);
	
КонецПроцедуры

//Процедура - запускает поток
//
//Параметры:
//	ИмяМетода - Строка - имя вызываемого метода
//	ПутьКМетоду - Строка - имя процедуры
//	Параметры - Массив - массив параметров
//
Процедура ЗапуститьПоток(ИмяМетода, ПутьКМетоду, Параметры = Неопределено) Экспорт
	
	Попытка
		
		ФоновыеЗадания.Выполнить(ПутьКМетоду, Параметры, ИмяМетода, ИмяМетода);
		
	Исключение
		
		// Запускаем фоновое задание со статическим ключем. Запуск других экземпляров должен заканчиваться ошибкой (паттерн синглтон).
		
	КонецПопытки;
	
КонецПроцедуры

//Функция - отключает потоки, если 5 раз не получал датаграму настроек Tcp
//
Функция ОтключитьПотокиПоТаймауту()
	
	ПределЗначенияСчетчика = 5;
	
	ТекущееЗначениеСчетчика = сшпРаботаСКонстантами.ПолучитьЗначениеКонстанты("сшпКоличествоНеудачныхПопытокTcp");
	
	Если ТекущееЗначениеСчетчика = ПределЗначенияСчетчика Тогда
		
		Если АварийныйЗапрос() Тогда
			ТекущееЗначениеСчетчика = ТекущееЗначениеСчетчика + 1;
			сшпРаботаСКонстантами.УстановитьЗначениеКонстанты("сшпКоличествоНеудачныхПопытокTcp", ТекущееЗначениеСчетчика);
			ЗаписьЖурналаРегистрации("Datareon.Аварийный запрос", УровеньЖурналаРегистрации.Предупреждение,,, "Был отправлен аварийный запрос в адаптер по таймауту конфигурации от NM");
			Возврат Ложь;
		Иначе
			Возврат Истина;
		КонецЕсли;			
		
	ИначеЕсли ТекущееЗначениеСчетчика > ПределЗначенияСчетчика Тогда

		Возврат Истина;
		
	Иначе
		
		ТекущееЗначениеСчетчика = ТекущееЗначениеСчетчика + 1;
		сшпРаботаСКонстантами.УстановитьЗначениеКонстанты("сшпКоличествоНеудачныхПопытокTcp", ТекущееЗначениеСчетчика);
		
		Возврат Ложь;
	
	КонецЕсли;
		
КонецФункции

//Процедура - обнуляет счетчик отключения потоков по таймауту
//
Процедура ОбнулитьСчетчикОтключенияПотоков()
	
	сшпРаботаСКонстантами.УстановитьЗначениеКонстанты("сшпКоличествоНеудачныхПопытокTcp", 0);	

КонецПроцедуры

#КонецОбласти

#Область СервисныйПоток

//Процедура - Получение служебных сообщений
//
Процедура ПолучениеСлужебныхСообщений() Экспорт
	
	ВходящаяОчередь = Обработки.сшпВызовыКомпоненты.Создать();     
	ВходящаяОчередь.ИнициализироватьКомпоненту();  
	
	СтруктураСоединения = ПолучитьСтруктуруСоединения();
	СтруктураСоединения.Компонента = ВходящаяОчередь;
	СтруктураСоединения.Сервисный = 1;
	СтруктураСоединения.Режим = 0;
	
	Если Не УстановитьСоединение(СтруктураСоединения) Тогда
		
		Возврат;
		
	КонецЕсли;                                 
	
	ФорматПакета = сшпКэшируемыеФункции.ФорматСообщенийПоУмолчанию();
	ВерсияПараметровПодсистемы = сшпФункциональныеОпции.ВерсияПараметровПодсистемы();
	
	Пока Истина Цикл
		
		Если Не ПроверитьРазрешениеНаРаботу(ВерсияПараметровПодсистемы, Перечисления.сшпТипыОчередей.Системная, 0) Тогда
			
			Прервать;                    
			
		КонецЕсли;
		
		Если Не ПроверитьСоединение(ВходящаяОчередь) Тогда
			
			Если Не ВосстановитьСоединение(СтруктураСоединения) Тогда
			
				ЗаписьЖурналаРегистрации("Datareon.Tcp соединение, служебный поток", УровеньЖурналаРегистрации.Ошибка, , , "Соединение прервано!");
				сшпРаботаСКонстантами.УстановитьЗначениеКонстанты("сшпОтключитьСоединение", Истина);
				
				Прервать;
				
			Иначе
				
				ЗаписьЖурналаРегистрации("Datareon.Tcp соединение, служебный поток", УровеньЖурналаРегистрации.Предупреждение, , , "Соединение было восстановлено!");
				
			КонецЕсли;
			
		КонецЕсли;
				
		Попытка
			
			СообщениеПолучено = ВходящаяОчередь.CallAsFunc("GetNewTcpMessage", 1000);
			
		Исключение
			
			ТекстОшибки = "При получении сообщения из канала произошла ошибка: " + Символы.ПС + ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
			ЗапуститьПотокСЗадержкойАссинхронно("сшпTcp.ПолучениеСлужебныхСообщений", "сшпTcp.ПолучениеСлужебныхСообщений");
			сшпОбщегоНазначения.ЗарегистрироватьЗаписьВЖурнале(УровеньЖурналаРегистрации.Ошибка, "Datareon. Обработка очереди системных сообщений", ТекстОшибки);
			
			Прервать;    
			
		КонецПопытки;
		
		Если Не СообщениеПолучено Тогда
			
			Продолжить;
			
		КонецЕсли;
		
		ТипСообщения = ВходящаяОчередь.CallAsFunc("GetTcpType");
		Идентификатор = ВходящаяОчередь.CallAsFunc("GetTcpMessageId");
		КлассСообщения = ВходящаяОчередь.CallAsFunc("GetTcpClassID");
		ТелоПакета = ВходящаяОчередь.CallAsFunc("GetTcpMessage");
		
		Попытка
						
			//ТипСообщения = "GPS": не используется в текущем протоколе
			Если КлассСообщения = "CSM" Тогда			

				сшпСистемныеСообщения.ПолучитьСостояниеОбработки();
			
			ИначеЕсли КлассСообщения = "CSA" Тогда
				
				сткПараметры = сшпОбщегоНазначения.ПолучитьПараметрыСообщенияСтруктуройПоПакетуXML(ТелоПакета);
				
				Если сшпРаботаСДанными.УстановитьПараметрыАдаптера(сткПараметры) Тогда
					
					//изменились параметры, нужно выполнить перезапуск сеансов
					ЗапуститьПотокСЗадержкойАссинхронно("сшпTcp.ЗапуститьОбработчики", "сшпTcp.ЗапуститьОбработчики", 1);
					
				КонецЕсли;
				
			ИначеЕсли КлассСообщения = "GCM" Тогда
				
				мсвПараметры = Новый Массив;
				мсвПараметры.Добавить(Идентификатор);
				мсвПараметры.Добавить(ФорматПакета);
				мсвПараметры.Добавить(ТелоПакета);
				
				ФоновыеЗадания.Выполнить("сшпОбслуживаниеОчередей.ВыполнитьВнешнююКоманду", мсвПараметры, , "сшпОбслуживаниеОчередей.ВыполнитьВнешнююКоманду");
				
			ИначеЕсли ТипСообщения = "SUS" Тогда
				
				сткПараметры = сшпОбщегоНазначения.ПолучитьПараметрыСообщенияСтруктуройПоПакетуXML(ТелоПакета);
				мсвПараметры = Новый Массив;
				мсвПараметры.Добавить(Идентификатор);
				мсвПараметры.Добавить(сткПараметры);
				
				ФоновыеЗадания.Выполнить("сшпОбслуживаниеОчередей.УстановитьПараметрыПользователя", мсвПараметры, , "сшпОбслуживаниеОчередей.УстановитьПараметрыПользователя");
				
			ИначеЕсли КлассСообщения = "TUM" Тогда
				
				мсвПараметры = Новый Массив;
				мсвПараметры.Добавить(ФорматПакета);
				мсвПараметры.Добавить(ТелоПакета);
				
				ФоновыеЗадания.Выполнить("сшпСистемныеСообщения.ОбновитьОбработчикСобытия", мсвПараметры, Идентификатор, "ОбновитьОбработчикСобытия. id = " + Идентификатор);
				
			ИначеЕсли КлассСообщения = "TCS" Тогда
				
				мсвПараметры = Новый Массив;
				мсвПараметры.Добавить(ФорматПакета);
				мсвПараметры.Добавить(ТелоПакета);
				
				ФоновыеЗадания.Выполнить("сшпСистемныеСообщения.УправлениеСостояниемОбработчика", мсвПараметры, Идентификатор, "УправлениеСостояниемОбработчика. id = " + Идентификатор);
				
			ИначеЕсли КлассСообщения = "TRM" Тогда
				
				мсвПараметры = Новый Массив;
				мсвПараметры.Добавить(ФорматПакета);
				мсвПараметры.Добавить(ТелоПакета);
				
				ФоновыеЗадания.Выполнить("сшпСистемныеСообщения.УдалитьОбработчикСобытия", мсвПараметры, Идентификатор, "УдалитьОбработчикСобытия. id = " + Идентификатор);
				
			ИначеЕсли КлассСообщения = "TLR" Тогда
				
				ФоновыеЗадания.Выполнить("сшпСистемныеСообщения.ПолучитьСписокВерсийОбработчиковСобытий",, Идентификатор, "ПолучитьСписокВерсийОбработчиковСобытий. id = " + Идентификатор);
				
			ИначеЕсли КлассСообщения = "TSR" Тогда
				
				ФоновыеЗадания.Выполнить("сшпСистемныеСообщения.ПолучитьСписокОбработчиковСобытий",, Идентификатор, "ПолучитьСписокОбработчиковСобытий. id = " + Идентификатор);
				
			ИначеЕсли КлассСообщения = "FLR" Тогда
			
				ФоновыеЗадания.Выполнить("сшпСистемныеСообщения.ПолучитьСписокВерсийФункций",, Идентификатор, "ПолучитьСписокВерсийФункций. id = " + Идентификатор);
			
			ИначеЕсли КлассСообщения = "FSR" Тогда
			
				ФоновыеЗадания.Выполнить("сшпСистемныеСообщения.ПолучитьСписокФункций",, Идентификатор, "ПолучитьСписокФункций. id = " + Идентификатор);
				
			ИначеЕсли КлассСообщения = "FUM" Тогда
				
				мсвПараметры = Новый Массив;
				мсвПараметры.Добавить(ФорматПакета);
				мсвПараметры.Добавить(ТелоПакета);
				
				ФоновыеЗадания.Выполнить("сшпСистемныеСообщения.ОбновитьФункцию", мсвПараметры, Идентификатор, "ОбновитьФункцию. id = " + Идентификатор);
			
			ИначеЕсли КлассСообщения = "FCS" Тогда
				
				мсвПараметры = Новый Массив;
				мсвПараметры.Добавить(ФорматПакета);
				мсвПараметры.Добавить(ТелоПакета);
				
				ФоновыеЗадания.Выполнить("сшпСистемныеСообщения.УправлениеСостояниемФункции", мсвПараметры, Идентификатор, "УправлениеСостояниемФункции. id = " + Идентификатор);
			
			ИначеЕсли КлассСообщения = "FRM" Тогда
				
				мсвПараметры = Новый Массив;
				мсвПараметры.Добавить(ФорматПакета);
				мсвПараметры.Добавить(ТелоПакета);
				
				ФоновыеЗадания.Выполнить("сшпСистемныеСообщения.УдалитьФункцию", мсвПараметры, Идентификатор, "УдалитьФункцию. id = " + Идентификатор);
					
			ИначеЕсли КлассСообщения = "RML" Тогда
				
				мсвПараметры = Новый Массив;
				мсвПараметры.Добавить(ФорматПакета);
				мсвПараметры.Добавить(ТелоПакета);
				
				ФоновыеЗадания.Выполнить("сшпСистемныеСообщения.ВозвратПакетовВОбработку", мсвПараметры, Идентификатор, "ВозвратПакетовВОбработку. id = " + Идентификатор);
				
			ИначеЕсли КлассСообщения = "BMR" Тогда
				
				ФоновыеЗадания.Выполнить("сшпСистемныеСообщения.ПолучитьСтруктуруКонфигурации",, Идентификатор, "ПолучитьСтруктуруКонфигурации");
				
			ИначеЕсли КлассСообщения = "V1C" Тогда
				
				сшпСистемныеСообщения.ПолучитьВерсиюПодсистемы1С();
				
			ИначеЕсли КлассСообщения = "CSB" Тогда
				
				сшпСистемныеСообщения.ПолучитьПараметрыПодключения();
				
			ИначеЕсли КлассСообщения = "FND" ИЛИ ТипСообщения = "FND" Тогда    
				
				мсвПараметры = Новый Массив;
				мсвПараметры.Добавить(ФорматПакета);
				мсвПараметры.Добавить(ТелоПакета);
				мсвПараметры.Добавить(Идентификатор);
				
				ФоновыеЗадания.Выполнить("сшпСистемныеСообщения.НайтиСообщения", мсвПараметры, Идентификатор, "НайтиСообщения. id = " + Идентификатор);
				
			ИначеЕсли КлассСообщения = "DEB" ИЛИ ТипСообщения = "DEB" Тогда
				
				мсвПараметры = Новый Массив;   
				мсвПараметры.Добавить(ПолучитьФункциональнуюОпцию("сшпФорматСообщения"));
				мсвПараметры.Добавить(ТелоПакета);
				мсвПараметры.Добавить(Идентификатор);
				
				ФоновыеЗадания.Выполнить("сшпОтладкаОбработчиков.ВыполнитьОтладкуОбработчика", мсвПараметры, Идентификатор, "ВыполнитьОтладкуОбработчика. id = " + Идентификатор);
				
			ИначеЕсли КлассСообщения = "EMM" ИЛИ ТипСообщения = "EMM" Тогда
				
				СверкаКлючей(ТелоПакета);
							
			Иначе
								
				Если Не ТипСообщения = "TrackMessage" Тогда
				
					сшпСистемныеСообщения.ОтправитьСостояниеСообщения(Строка(Идентификатор), Перечисления.сшпСтатусыСообщений.НеВалидно, "Получен неизвестный тип сообщения " + Строка(ТипСообщения) + ", сообщение с данными должно иметь тип DTP", 0, Перечисления.сшпТипыИнтеграции.Входящая, КлассСообщения);
				
				КонецЕсли;
				
			КонецЕсли;
			
		Исключение
			
			ТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
			сшпОбщегоНазначения.ЗарегистрироватьЗаписьВЖурнале(УровеньЖурналаРегистрации.Ошибка, "Datareon. Обработка очереди системных сообщений", ТекстОшибки);
			
		КонецПопытки;
				
	КонецЦикла;
	
	ПрерватьСоединение(ВходящаяОчередь);
	
КонецПроцедуры

//Процедура - Обработать квитанции
//
Процедура ОбработатьКвитанции() Экспорт
	
	ОчередьКвитанций = Обработки.сшпВызовыКомпоненты.Создать();
	ОчередьКвитанций.ИнициализироватьКомпоненту();
	
	СтруктураСоединения = ПолучитьСтруктуруСоединения();
	СтруктураСоединения.Компонента = ОчередьКвитанций;
	СтруктураСоединения.Сервисный = 2;
	СтруктураСоединения.Режим = 0;
		
	Если Не УстановитьСоединение(СтруктураСоединения) Тогда
		
		Возврат;
		
	КонецЕсли;
	
	ВерсияПараметровПодсистемы = сшпФункциональныеОпции.ВерсияПараметровПодсистемы();
	
	Пока Истина Цикл
				
		Если Не ПроверитьРазрешениеНаРаботу(ВерсияПараметровПодсистемы, Перечисления.сшпТипыОчередей.Системная, 0) Тогда
			
			Прервать;                    
			
		КонецЕсли;
		
		Если Не ПроверитьСоединение(ОчередьКвитанций) Тогда
			
			Если Не ВосстановитьСоединение(СтруктураСоединения) Тогда
			
				ЗаписьЖурналаРегистрации("Datareon.Tcp соединение, служебный поток (квитанции)", УровеньЖурналаРегистрации.Ошибка, , , "Соединение прервано!");
				сшпРаботаСКонстантами.УстановитьЗначениеКонстанты("сшпОтключитьСоединение", Истина);
				
				Прервать;
				
			Иначе
				
				ЗаписьЖурналаРегистрации("Datareon.Tcp соединение, служебный поток (квитанции)", УровеньЖурналаРегистрации.Предупреждение, , , "Соединение было восстановлено!");
				
			КонецЕсли;
			
		КонецЕсли;
		
		Идентификатор = "";
		ТекстСообщения = "";
		
		Попытка
			
			РезультатОбработки = ОчередьКвитанций.CallAsFunc("GetTcpAckMessage", Идентификатор, ТекстСообщения);
			
		Исключение
			
			ТекстОшибки = "При получении сообщения из сервисного канала произошла ошибка: " + Символы.ПС + ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());		
			сшпОбщегоНазначения.ЗарегистрироватьЗаписьВЖурнале(УровеньЖурналаРегистрации.Ошибка, "Datareon. Обработка очереди квитанций", ТекстОшибки);
			
			Прервать;
			
		КонецПопытки;
		
		Если (РезультатОбработки >= 0) Тогда
			
			СостояниеСообщения = сшпКэшируемыеФункции.ПолучитьОбщееСостояниеОбработкиСообщенияПоКоду(РезультатОбработки);
			сшпРаботаСДанными.УстановитьСостояниеСообщения(Идентификатор, СостояниеСообщения, 0, ТекстСообщения, , , Перечисления.сшпТипыИнтеграции.Исходящая, , Идентификатор);	
			
		Иначе
			
			сшпОбщегоНазначения.Ожидание(1);
			
		КонецЕсли;		
		
	КонецЦикла;
	
	ПрерватьСоединение(ОчередьКвитанций);
	
КонецПроцедуры

//Процедура - Установить соединение и отправить служебное сообщение
//
//Параметры:
//	XDTOПакет - Структура - содержит поля соответствующие описанию формата объекта Message1C
//
Процедура УстановитьСоединениеИОтправитьСлужебноеСообщение(XDTOПакет) Экспорт
	
	Очередь = Обработки.сшпВызовыКомпоненты.Создать();
	Очередь.ИнициализироватьКомпоненту();
	
	СтруктураСоединения = ПолучитьСтруктуруСоединения();
	СтруктураСоединения.Компонента = Очередь;
	СтруктураСоединения.Сервисный = 1;
	СтруктураСоединения.Режим = 1;
	
	Если УстановитьСоединение(СтруктураСоединения) Тогда
	
		xmlПакет = сшпОбщегоНазначения.СформироватьСообщениеESB_HTTP(ФабрикаXDTO, XDTOПакет);
		
		ОтправитьСообщение(Очередь, xmlПакет);
		
		ПрерватьСоединение(Очередь);
				                                 
	КонецЕсли;
	
КонецПроцедуры

#КонецОбласти

#Область ВходящийПоток

//Функция - обрабатывает входящее сообщение
//
//Параметры:
//	Идентификатор - Строка - идентификатор передаваемого сообщения
//	КлассСообщения - Строка - класс сообщения
//	ОбъектСобытия - Строка - текст сообщения
//	СткОбработчик - Фиксированная структура - структура обработчика для входящего сообщения
//	ФорматСообщения - Перечисление.сшпФорматыСообщений - формат входящего сообщения
//	Задержка - Число - Количество секунд задержки перед обработкой
//	ТекстОшибки - Строка - возвращаемый текст ошибки
//	ДатаРегистрации - Дата - Дата/время регистрации сообщения в очереди
//	Компонента - ВнешняяКомпонента - Экземпляр внешней компоненты
//
//Возвращаемое значение:
//	Перечисление.сшпСтатусыСообщений - статус сообщения после обработки
//
Функция ВыполнитьОбработкуВходящегоСообщения(Знач Идентификатор, Знач КлассСообщения, ОбъектСобытия, СткОбработчик, Знач ФорматСообщения, Задержка, ТекстОшибки, ДатаРегистрации, Компонента)
	
	СостояниеСообщения = Перечисления.сшпСтатусыСообщений.Обработано;
	ФорматОберткиСообщения = сшпКэшируемыеФункции.ФорматСообщенийПоУмолчанию();		
		
	Попытка
				
		ОбъектСообщение = сшпОбщегоНазначения.ПолучитьОбъектXDTO(ФорматОберткиСообщения, ОбъектСобытия);
				
	Исключение
		
		//Сообщение не валидно
		ТекстОшибки = "Не удалось десериализовать сообщение " + ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		СостояниеСообщения = Перечисления.сшпСтатусыСообщений.НеВалидно;
		
	КонецПопытки;
		
	Если СостояниеСообщения = Перечисления.сшпСтатусыСообщений.Обработано Тогда
		
		КоличествоПопытокОжидания = сшпОбщегоНазначения.ПолучитьКоличествоПопытокОжидания(ОбъектСообщение);
		
		Попытка
			
			сшпОбщегоНазначения.ВыполнитьКодВходящегоОбработчика(сткОбработчик.ПроцедураОбработки, Идентификатор,
				КлассСообщения, ОбъектСобытия, СткОбработчик, ФорматСообщения, Задержка, ТекстОшибки, ДатаРегистрации,
				КоличествоПопытокОжидания, ОбъектСообщение, СостояниеСообщения);
			
		Исключение 
		
			ТекстОшибки = сшпОбщегоНазначения.ДополнитьТекстОшибки(сшпОбщегоНазначения.ПолучитьТекстОшибкиОбработчика(ИнформацияОбОшибке()), СткОбработчик, Неопределено);
				
			СостояниеСообщения = Перечисления.сшпСтатусыСообщений.ОшибкаОбработки;
			
		КонецПопытки;
		
	КонецЕсли;
	
	Возврат СостояниеСообщения;
	
КонецФункции

//Процедура - Получение транспортных сообщений
//
//Параметры:
//	ИндексПотока - Число - индекс запускаемого потока
//
Процедура ПолучениеТранспортныхСообщений(ИндексПотока) Экспорт

	ТекстОшибки = "";
	АварийноеЗавершение = Ложь;
	
	ВходящаяОчередь = Обработки.сшпВызовыКомпоненты.Создать();     
	ВходящаяОчередь.ИнициализироватьКомпоненту();  
	
	ИсходящаяОчередь = Обработки.сшпВызовыКомпоненты.Создать();     
	ИсходящаяОчередь.ИнициализироватьКомпоненту();  

	СтруктураСоединенияВх = ПолучитьСтруктуруСоединения();
	СтруктураСоединенияВх.Компонента = ВходящаяОчередь;
	СтруктураСоединенияВх.Сервисный = 0;
	СтруктураСоединенияВх.Режим = 0;

	Если Не УстановитьСоединение(СтруктураСоединенияВх) Тогда

		Возврат;

	КонецЕсли;

	СтруктураСоединенияИсх = ПолучитьСтруктуруСоединения();
	СтруктураСоединенияИсх.Компонента = ИсходящаяОчередь;
	СтруктураСоединенияИсх.Сервисный = 0;
	СтруктураСоединенияИсх.Режим = 1;

	Если Не УстановитьСоединение(СтруктураСоединенияИсх) Тогда

		Возврат;

	КонецЕсли;

	ФорматПакета = ПолучитьФункциональнуюОпцию("сшпФорматСообщения");
	ВерсияПараметровПодсистемы = сшпФункциональныеОпции.ВерсияПараметровПодсистемы();

	СостояниеПоследнегоСообщения = Новый Структура;
	СостояниеПоследнегоСообщения.Вставить("Идентификатор", "");
	СостояниеПоследнегоСообщения.Вставить("СостояниеСообщения", "");
	СостояниеПоследнегоСообщения.Вставить("Задержка", "");
	СостояниеПоследнегоСообщения.Вставить("ТекстОшибкиОбработкиСообщения", "");
	СостояниеПоследнегоСообщения.Вставить("КлассСообщения", "");

	Пока Истина Цикл

		Если Не ПроверитьРазрешениеНаРаботу(ВерсияПараметровПодсистемы, Перечисления.сшпТипыОчередей.Входящая,
			ИндексПотока) Тогда
			
			//Если было обработано сообщение и канал разрушился, то квитанция могла быть потеряна. Отправим квитанцию по отдельному каналу
			Если СостояниеПоследнегоСообщения.Идентификатор <> "" Тогда

				ПотвердитьОбработкуВходящегоСообщенияПоВременномуКаналу(
					СостояниеПоследнегоСообщения.Идентификатор, СостояниеПоследнегоСообщения.СостояниеСообщения,
					СостояниеПоследнегоСообщения.Задержка, СостояниеПоследнегоСообщения.ТекстОшибкиОбработкиСообщения,
					СостояниеПоследнегоСообщения.КлассСообщения);

			КонецЕсли;

			Прервать;

		КонецЕсли;

		Если Не ПроверитьСоединение(ВходящаяОчередь) Тогда

			Если Не ВосстановитьСоединение(СтруктураСоединенияВх) Тогда

				ЗаписьЖурналаРегистрации("Datareon.Tcp соединение, получение транспортных сообщений № " + Строка(
					ИндексПотока), УровеньЖурналаРегистрации.Ошибка, , , "Соединение прервано!");
				сшпРаботаСКонстантами.УстановитьЗначениеКонстанты("сшпОтключитьСоединение", Истина);

				Прервать;

			Иначе

				СтруктураСоединенияИсх.Компонента.CallAsFunc("StopTcp");

				Если Не УстановитьСоединение(СтруктураСоединенияИсх) Тогда

					Возврат;

				КонецЕсли;

				ЗаписьЖурналаРегистрации("Datareon.Tcp соединение, получение транспортных сообщений № " + Строка(
					ИндексПотока), УровеньЖурналаРегистрации.Предупреждение, , , "Соединение было восстановлено!");

			КонецЕсли;

		КонецЕсли;

		Попытка

			СообщениеПолучено = ВходящаяОчередь.CallAsFunc("GetNewTcpMessage", 1000);

		Исключение

			ТекстОшибки = "При получении сообщения произошла ошибка: " + Символы.ПС + ПодробноеПредставлениеОшибки(
				ИнформацияОбОшибке());

			ЗапуститьПотокСЗадержкойАссинхронно("сшпTcp.ЗапуститьПотокОбменаТранспортнымиСообщениями",
				"сшпTcp.ЗапуститьПотокОбменаТранспортнымиСообщениями");

			сшпОбщегоНазначения.ЗарегистрироватьЗаписьВЖурнале(УровеньЖурналаРегистрации.Ошибка,
				"Datareon. Обработка очереди системных сообщений", ТекстОшибки);

			АварийноеЗавершение = Истина;

			Прервать;

		КонецПопытки;

		Если Не СообщениеПолучено Тогда

			Продолжить;

		КонецЕсли;

		ТипСообщения = ВходящаяОчередь.CallAsFunc("GetTcpType");
		Идентификатор = ВходящаяОчередь.CallAsFunc("GetTcpMessageId");
		КлассСообщения = ВходящаяОчередь.CallAsFunc("GetTcpClassID");
		СткОбработчик = сшпКэшируемыеФункции.ПолучитьОбработчик(КлассСообщения,
			Перечисления.сшпТипыИнтеграции.Входящая, сшпФункциональныеОпции.ВерсияОбработчиков());

		Если Не СткОбработчик.ОбработчикНайден Тогда

			ПотвердитьОбработкуВходящегоСообщения(Идентификатор, ИсходящаяОчередь,
				Перечисления.сшпСтатусыСообщений.ОтсутствуетОбработчик, , "Отсутствует обработчик для класса "
				+ КлассСообщения, КлассСообщения, СостояниеПоследнегоСообщения);

			Продолжить;

		ИначеЕсли СткОбработчик.Отключен Тогда

			ПотвердитьОбработкуВходящегоСообщения(Идентификатор, ИсходящаяОчередь,
				Перечисления.сшпСтатусыСообщений.ОбработкаОтменена, , "Обработчик для класса " + КлассСообщения
				+ " найден, но отключен.", КлассСообщения, СостояниеПоследнегоСообщения);

			Продолжить;

		КонецЕсли;

		ОбъектСобытия = ВходящаяОчередь.CallAsFunc("GetTcpMessage");

		ТекстОшибкиОбработкиСообщения = "";
		Задержка = 0;

		ДатаРегистрации = МестноеВремя(ВходящаяОчередь.CallAsFunc("GetTcpCreationTime"), ЧасовойПояс());

		СостояниеСообщения = ВыполнитьОбработкуВходящегоСообщения(Идентификатор, КлассСообщения, ОбъектСобытия,
			сткОбработчик, форматПакета, Задержка, ТекстОшибкиОбработкиСообщения, ДатаРегистрации, ВходящаяОчередь);

		Если СостояниеСообщения = Перечисления.сшпСтатусыСообщений.ОжиданиеОбработки И Не ЗначениеЗаполнено(Задержка) тогда

			Задержка = 30;
	
			ТекстПредупреждения = "Задержка в ожидании обработки не может быть равна 0 с. Установлена задержка 30 с.";
	
			ЗаписьЖурналаРегистрации("Datareon. Обработка сообщения", УровеньЖурналаРегистрации.Предупреждение, ,
				Идентификатор, ТекстПредупреждения);
				
		КонецЕсли;	

		ПотвердитьОбработкуВходящегоСообщения(Идентификатор, ИсходящаяОчередь, СостояниеСообщения, Задержка,
			ТекстОшибкиОбработкиСообщения, КлассСообщения, СостояниеПоследнегоСообщения);

		Если СостояниеСообщения = Перечисления.сшпСтатусыСообщений.НеВалидно Тогда

			ЗаписьЖурналаРегистрации("Datareon. Обработка сообщения", УровеньЖурналаРегистрации.Ошибка, ,
				Идентификатор, ТекстОшибкиОбработкиСообщения);

		ИначеЕсли СостояниеСообщения = Перечисления.сшпСтатусыСообщений.ОшибкаОбработки Тогда

			ЗаписьЖурналаРегистрации("Datareon. Обработка сообщения", УровеньЖурналаРегистрации.Ошибка, ,
				Идентификатор, ТекстОшибкиОбработкиСообщения);

		КонецЕсли;

	КонецЦикла;

	ПрерватьСоединение(ВходящаяОчередь);
	ПрерватьСоединение(ИсходящаяОчередь);

	Если АварийноеЗавершение Тогда

		ВызватьИсключение ТекстОшибки;

	КонецЕсли;

КонецПроцедуры

//Процедура - Подтверждает обработку входящего сообщения
//
//Параметры:
//	Идентификатор - Строка - идентификатор сообщения
//	Очередь - ВнешняяКомпонента - экземпляр внешней компоненты обработки очереди
//	Состояние - Перечисление.сшпСтатусыСообщений - состояние сообщения
//	Задержка - Число - количество секунд обработки сообщения
//	ТекстОшибки - Строка - возвращаемый текст ошибки
//	КлассСообщения - Строка - класс входящего сообщения
//	СостояниеПоследнегоСообщения - Структура - класс входящего сообщения
//
Процедура ПотвердитьОбработкуВходящегоСообщения(Идентификатор, Очередь, Состояние, Задержка = 0, ТекстОшибки = "",
	КлассСообщения = "", СостояниеПоследнегоСообщения)

	КодСостояния = сшпКэшируемыеФункции.ПолучитьОбщийКодСостоянияОбработки(Состояние,
		Перечисления.сшпТипыИнтеграции.Входящая);

	Попытка
		Очередь.CallAsFunc("SendTcpAckMessage", Идентификатор, КодСостояния, ТекстОшибки, КлассСообщения, Задержка);

		СостояниеПоследнегоСообщения.Вставить("Идентификатор", Идентификатор);
		СостояниеПоследнегоСообщения.Вставить("СостояниеСообщения", Состояние);
		СостояниеПоследнегоСообщения.Вставить("Задержка", Задержка);
		СостояниеПоследнегоСообщения.Вставить("ТекстОшибкиОбработкиСообщения", ТекстОшибки);
		СостояниеПоследнегоСообщения.Вставить("КлассСообщения", КлассСообщения);
	Исключение
		ПотвердитьОбработкуВходящегоСообщенияПоВременномуКаналу(Идентификатор, Состояние, Задержка, ТекстОшибки,
			КлассСообщения);

		Если СостояниеПоследнегоСообщения.Идентификатор <> "" Тогда
			ПотвердитьОбработкуВходящегоСообщенияПоВременномуКаналу(
						СостояниеПоследнегоСообщения.Идентификатор, СостояниеПоследнегоСообщения.СостояниеСообщения,
				СостояниеПоследнегоСообщения.Задержка, СостояниеПоследнегоСообщения.ТекстОшибкиОбработкиСообщения,
				СостояниеПоследнегоСообщения.КлассСообщения);
			СостояниеПоследнегоСообщения.Идентификатор = "";
		КонецЕсли;
	КонецПопытки;

КонецПроцедуры

//Процедура - Подтверждает обработку входящего сообщения по временному каналу
//
//Параметры:
//	Идентификатор - Строка - идентификатор сообщения
//	Состояние - Перечисление.сшпСтатусыСообщений - состояние сообщения
//	Задержка - Число - количество секунд обработки сообщения
//	ТекстОшибки - Строка - возвращаемый текст ошибки
//	КлассСообщения - Строка - класс входящего сообщения
//
Процедура ПотвердитьОбработкуВходящегоСообщенияПоВременномуКаналу(Идентификатор, Состояние, Задержка = 0,
	ТекстОшибки = "", КлассСообщения = "")

	КодСостояния = сшпКэшируемыеФункции.ПолучитьОбщийКодСостоянияОбработки(Состояние,
		Перечисления.сшпТипыИнтеграции.Входящая);

	ВременныйКанал = Обработки.сшпВызовыКомпоненты.Создать();
	ВременныйКанал.ИнициализироватьКомпоненту();

	СтруктураСоединения = ПолучитьСтруктуруСоединения();
	СтруктураСоединения.Компонента = ВременныйКанал;
	СтруктураСоединения.Сервисный = 1;
	СтруктураСоединения.Режим = 1;

	Если УстановитьСоединение(СтруктураСоединения) Тогда
		ВременныйКанал.CallAsFunc("SendTcpAckMessage", Идентификатор, КодСостояния, ТекстОшибки, КлассСообщения, Задержка);
		ПрерватьСоединение(ВременныйКанал);
	КонецЕсли;

КонецПроцедуры

#КонецОбласти

#Область ИсходящийПоток

//Процедура - обработка очереди исходящих сообщения
//
Процедура ОбработкаОчередиИсходящихСообщений() Экспорт 

	КоличествоСообщенийБуфера = 50;
	ДлительностьОжиданияКвитанций = 600; //в секундах
	КоличествоПотоков = сшпРаботаСКонстантами.МаксимальноеКоличествоПотоковОбработкиИсходящих();
			
	Запрос = Новый Запрос;		
	Запрос.Текст =
		"ВЫБРАТЬ ПЕРВЫЕ " + Формат(КоличествоПотоков*КоличествоСообщенийБуфера, "ЧГ=0") + "
		|	сшпСостояниеСообщений.ИндексПотока КАК ИндексПотока,
		|	1 КАК Количество
		|ПОМЕСТИТЬ ВТРезультатВОбработке
		|ИЗ
		|	РегистрСведений.сшпСостояниеСообщений КАК сшпСостояниеСообщений
		|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.сшпОчередьИсходящихСообщений КАК сшпОчередьИсходящихСообщений
		|		ПО сшпСостояниеСообщений.ИдентификаторСобытия = сшпОчередьИсходящихСообщений.ИдентификаторСобытия
		|ГДЕ
		|	сшпСостояниеСообщений.СтатусСообщения = ЗНАЧЕНИЕ(Перечисление.сшпСтатусыСообщений.ВОбработке)
		|	И сшпСостояниеСообщений.ЗадержкаЧисло <= &Задержка
		|УПОРЯДОЧИТЬ ПО
		|	сшпОчередьИсходящихСообщений.ДатаРегистрации
		|;
		|
		|////////////////////////////////////////////////////////////////////////////////
		|ВЫБРАТЬ ПЕРВЫЕ " + Формат(КоличествоПотоков*КоличествоСообщенийБуфера, "ЧГ=0") + "
		|	сшпСостояниеСообщений.ИндексПотока КАК ИндексПотока,
		|	сшпСостояниеСообщений.СтатусСообщения КАК СтатусСообщения,
		|	сшпОчередьИсходящихСообщений.ИдентификаторСобытия КАК ИдентификаторСобытия
		|ПОМЕСТИТЬ кРаспределениюРабочие
		|ИЗ
		|	РегистрСведений.сшпОчередьИсходящихСообщений КАК сшпОчередьИсходящихСообщений
		|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.сшпСостояниеСообщений КАК сшпСостояниеСообщений
		|		ПО сшпОчередьИсходящихСообщений.ИдентификаторСобытия = сшпСостояниеСообщений.ИдентификаторСобытия
		|ГДЕ
		|	сшпСостояниеСообщений.СтатусСообщения В(&СтатусСообщенияКАнализу)
		|	И сшпСостояниеСообщений.ЗадержкаЧисло <= &Задержка
		|	И сшпСостояниеСообщений.ИндексПотока = 0
		|УПОРЯДОЧИТЬ ПО
		|	сшпОчередьИсходящихСообщений.ДатаРегистрации
		|;
		|
		|////////////////////////////////////////////////////////////////////////////////
		|ВЫБРАТЬ
		|	кРаспределению.ИдентификаторСобытия КАК ИдентификаторСобытия,
		|	кРаспределению.СтатусСообщения КАК СтатусСообщения
		|ИЗ
		|	кРаспределениюРабочие КАК кРаспределению
		|ГДЕ
		|	кРаспределению.СтатусСообщения В(&СтатусСообщенияНераспределенные)
		|;
		|
		|////////////////////////////////////////////////////////////////////////////////
		|ВЫБРАТЬ
		|	кРаспределению.ИндексПотока КАК ИндексПотока,
		|	СУММА(1) КАК Количество
		|ПОМЕСТИТЬ ВТКоличествоСообщений
		|ИЗ
		|	кРаспределениюРабочие КАК кРаспределению
		|ГДЕ
		|	кРаспределению.ИндексПотока <> 0
		|
		|СГРУППИРОВАТЬ ПО
		|	кРаспределению.ИндексПотока
		|
		|ОБЪЕДИНИТЬ ВСЕ
		|
		|ВЫБРАТЬ
		|	ВТРезультатВОбработке.ИндексПотока,
		|	ВТРезультатВОбработке.Количество
		|ИЗ
		|	ВТРезультатВОбработке КАК ВТРезультатВОбработке
		|;
		|
		|////////////////////////////////////////////////////////////////////////////////
		|ВЫБРАТЬ
		|	ВТКоличествоСообщений.ИндексПотока КАК ИндексПотока,
		|	СУММА(ВТКоличествоСообщений.Количество) КАК Количество
		|ИЗ
		|	ВТКоличествоСообщений КАК ВТКоличествоСообщений
		|
		|СГРУППИРОВАТЬ ПО
		|	ВТКоличествоСообщений.ИндексПотока";
		
	СтатусСообщенияНераспределенные = сшпКэшируемыеФункции.ПоучитьСписокРабочихСтатусов();	
		
	Запрос.УстановитьПараметр("СтатусСообщенияКАнализу", СтатусСообщенияНераспределенные);
	Запрос.УстановитьПараметр("СтатусСообщенияНераспределенные", СтатусСообщенияНераспределенные);	
	
	ЗапросПоискЗависших = Новый Запрос;
	ЗапросПоискЗависших.Текст = 
		"ВЫБРАТЬ
		|	сшпОчередьИсходящихСообщений.ИдентификаторСобытия КАК Идентификатор
		|ИЗ
		|	РегистрСведений.сшпОчередьИсходящихСообщений КАК сшпОчередьИсходящихСообщений
		|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.сшпСостояниеСообщений КАК сшпСостояниеСообщений
		|		ПО сшпОчередьИсходящихСообщений.ИдентификаторСобытия = сшпСостояниеСообщений.ИдентификаторСобытия
		|ГДЕ
		|	сшпСостояниеСообщений.СтатусСообщения = ЗНАЧЕНИЕ(Перечисление.сшпСтатусыСообщений.ВОбработке)
		|	И (сшпСостояниеСообщений.ИндексПотока > &КоличествоПотоков
		|			ИЛИ сшпСостояниеСообщений.ИндексПотока = 0)
		|
		|ОБЪЕДИНИТЬ ВСЕ
		|
		|ВЫБРАТЬ
		|	сшпОчередьИсходящихСообщений.ИдентификаторСобытия
		|ИЗ
		|	РегистрСведений.сшпОчередьИсходящихСообщений КАК сшпОчередьИсходящихСообщений
		|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.сшпСостояниеСообщений КАК сшпСостояниеСообщений
		|		ПО сшпОчередьИсходящихСообщений.ИдентификаторСобытия = сшпСостояниеСообщений.ИдентификаторСобытия
		|ГДЕ
		|	сшпСостояниеСообщений.СтатусСообщения = ЗНАЧЕНИЕ(Перечисление.сшпСтатусыСообщений.Отправлено)
		|	И сшпСостояниеСообщений.ДатаИзменения < &ДатаОтправки";	
	ЗапросПоискЗависших.УстановитьПараметр("КоличествоПотоков", КоличествоПотоков);
	
	Пока сшпФункциональныеОпции.ИспользоватьСШП() И 
		Не сшпФункциональныеОпции.ОтключитьПотоки() И 
		Не сшпФункциональныеОпции.ОтключитьСоединение() И
		Не КонфигурацияБазыДанныхИзмененаДинамически() Цикл 
		
		Запрос.УстановитьПараметр("Задержка", сшпОбщегоНазначения.ПеревестиДатуВЧисло(ТекущаяДатаСеанса()));
		
		//@skip-check query-in-loop
		РезультатЗапроса = Запрос.ВыполнитьПакет();
		//РезультатЗапроса[2]: идентификаторы нераспределенных сообщений
		//РезультатЗапроса[4]: количество сообщений, находящиеся сейчас в обработке по каждому потоку
		
		СделатьПаузу = Истина;
		
		Если Не РезультатЗапроса[2].Пустой() Тогда //есть сообщения к распределению
			
			СделатьПаузу = Ложь;
			
			ВыборкаИдентификаторов = РезультатЗапроса[2].Выбрать();
			ВыборкаПотоков = РезультатЗапроса[4].Выбрать();
			
			ИндексПотока = 0;		
			КоличествоВПотоке = КоличествоСообщенийБуфера; //инициализируем первое значение, превышающее буфер для перехода на следующий поток			
			ЕстьИзменения = Ложь;
			
			Пока ВыборкаИдентификаторов.Следующий() Цикл
				
				Пока КоличествоСообщенийБуфера <= КоличествоВПотоке Цикл    //буфер потока переполнен, перейдем к следующему
					
					ИндексПотока = ИндексПотока + 1;
					
					Если ВыборкаПотоков.НайтиСледующий(ИндексПотока, "ИндексПотока") Тогда 
						
						КоличествоВПотоке = ВыборкаПотоков.Количество;
						
					Иначе
						
						КоличествоВПотоке = 0;
						
					КонецЕсли;
					
				КонецЦикла;
				
				Если ИндексПотока > КоличествоПотоков Тогда
					
					Если Не ЕстьИзменения Тогда
						сшпОбщегоНазначения.ОжиданиеМСек(100);
						СделатьПаузу = Ложь;	
					Иначе
						СделатьПаузу = Истина;
					Конецесли;
					
					Прервать;
					
				КонецЕсли;
				
				ЕстьИзменения = Истина;
				
				текИдентификатор = ВыборкаИдентификаторов.ИдентификаторСобытия;
				сшпРаботаСДанными.УстановитьСостояниеСообщения(текИдентификатор, Перечисления.сшпСтатусыСообщений.ВОбработке, , , ИндексПотока, , Перечисления.сшпТипыИнтеграции.Исходящая);
				
				КоличествоВПотоке = КоличествоВПотоке + 1;
				
			КонецЦикла;
			
		КонецЕсли;		
		
		ЗапросПоискЗависших.УстановитьПараметр("ДатаОтправки", ТекущаяДатаСеанса() - ДлительностьОжиданияКвитанций);
		//@skip-check query-in-loop
		РезультатПоискаЗависших = ЗапросПоискЗависших.Выполнить();
		
		Если Не РезультатПоискаЗависших.Пустой() Тогда
			
			СделатьПаузу = Ложь;
			
			ВыборкаДетальныеЗаписи = РезультатПоискаЗависших.Выбрать();
			
			Пока ВыборкаДетальныеЗаписи.Следующий() Цикл
				
				сшпРаботаСДанными.УстановитьСостояниеСообщения(ВыборкаДетальныеЗаписи.Идентификатор, Перечисления.сшпСтатусыСообщений.ОжиданиеОбработки, , , , , Перечисления.сшпТипыИнтеграции.Исходящая);
				
			КонецЦикла;
			
		КонецЕсли;
		
		Если СделатьПаузу Тогда
			
			сшпОбщегоНазначения.Ожидание(1);
			
		КонецЕсли;

	КонецЦикла;
	
КонецПроцедуры

//Процедура - Передача транспортных сообщений
//
//Параметры:
//	ИндексПотока - Число - индекс потока
// 
Процедура ПередачаТранспортныхСообщений(ИндексПотока) Экспорт 

	ИсходящаяОчередь = Обработки.сшпВызовыКомпоненты.Создать();
	ИсходящаяОчередь.ИнициализироватьКомпоненту();
	
	СтруктураСоединения = ПолучитьСтруктуруСоединения();
	СтруктураСоединения.Компонента = ИсходящаяОчередь;
	СтруктураСоединения.Сервисный = 0;
	СтруктураСоединения.Режим = 1;
	
	Если Не УстановитьСоединение(СтруктураСоединения) Тогда
		
		Возврат;
	
	КонецЕсли;
				
	ФорматСообщения = сшпКэшируемыеФункции.ФорматСообщенийПоУмолчанию();
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
	"ВЫБРАТЬ ПЕРВЫЕ 50
	|	сшпСостояниеСообщений.СтатусСообщения КАК СтатусСообщения,
	|	сшпОчередьИсходящихСообщений.ИдентификаторСобытия КАК ИдентификаторСобытия,
	|	сшпСостояниеСообщений.ИдентификаторСообщения,
	|	сшпОчередьИсходящихСообщений.Хранилище КАК Хранилище,
	|	сшпОчередьИсходящихСообщений.ДатаРегистрации КАК ДатаРегистрации,
	|	сшпОчередьИсходящихСообщений.ОбъектСобытия КАК ОбъектСобытия,
	|	сшпОчередьИсходящихСообщений.ФорматСообщения КАК ФорматСообщения,
	|	сшпОчередьИсходящихСообщений.МетодХранения КАК МетодХранения,
	|	сшпОчередьИсходящихСообщений.ЭтоУдаление КАК ЭтоУдаление,
	|	сшпОчередьИсходящихСообщений.СсылкаНаОбъект КАК СсылкаНаОбъект
	|ИЗ
	|	РегистрСведений.сшпОчередьИсходящихСообщений КАК сшпОчередьИсходящихСообщений
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.сшпСостояниеСообщений КАК сшпСостояниеСообщений
	|		ПО сшпОчередьИсходящихСообщений.ИдентификаторСобытия = сшпСостояниеСообщений.ИдентификаторСобытия
	|ГДЕ
	|	сшпСостояниеСообщений.СтатусСообщения = ЗНАЧЕНИЕ(Перечисление.сшпСтатусыСообщений.ВОбработке)
	|	И сшпСостояниеСообщений.ИндексПотока = &ИндексПотока
	|УПОРЯДОЧИТЬ ПО
	|	сшпСостояниеСообщений.ДатаИзменения";
		
	СтатусСообщенияНераспределенные = сшпКэшируемыеФункции.ПоучитьСписокРабочихСтатусов();
	
	СтатусСообщенияКАнализу = сшпКэшируемыеФункции.ПоучитьСписокРабочихСтатусов();
	
	СтатусСообщенияКАнализу.Добавить(Перечисления.сшпСтатусыСообщений.ВОбработке);
		
	Запрос.УстановитьПараметр("ИндексПотока", ИндексПотока);
	ВерсияПараметровПодсистемы = сшпФункциональныеОпции.ВерсияПараметровПодсистемы();
		
	Пока Истина Цикл
				
		Если Не ПроверитьРазрешениеНаРаботу(ВерсияПараметровПодсистемы, Перечисления.сшпТипыОчередей.Исходящая, ИндексПотока) Тогда
						
			Прервать;
			
		КонецЕсли;
		
		Если Не ПроверитьСоединение(ИсходящаяОчередь) Тогда
			
			Если Не ВосстановитьСоединение(СтруктураСоединения) Тогда
			
				ЗаписьЖурналаРегистрации("Datareon.Tcp соединение, передача транспортных сообщений № " + строка(ИндексПотока), УровеньЖурналаРегистрации.Ошибка, , , "Соединение прервано!");
				сшпРаботаСКонстантами.УстановитьЗначениеКонстанты("сшпОтключитьСоединение", Истина);
				
				Прервать;
				
			Иначе
				
				ЗаписьЖурналаРегистрации("Datareon.Tcp соединение, передача транспортных сообщений № " + строка(ИндексПотока), УровеньЖурналаРегистрации.Предупреждение, , , "Соединение было восстановлено!");
				
			КонецЕсли;
			
		КонецЕсли;
		
		РезультатЗапроса = Запрос.Выполнить();
			
		Если РезультатЗапроса.Пустой() Тогда
			
			сшпОбщегоНазначения.Ожидание(1);
			
		Иначе
						
			Выборка = РезультатЗапроса.Выбрать();
			
			Пока Выборка.Следующий() Цикл 
				
				ИдентификаторСобытия = Выборка.ИдентификаторСобытия;
				ИдентификаторСообщения = Выборка.ИдентификаторСообщения;
								
				сткОбработчик = сшпКэшируемыеФункции.ПолучитьОбработчик(Выборка.ОбъектСобытия, Перечисления.сшпТипыИнтеграции.Исходящая, сшпФункциональныеОпции.ВерсияОбработчиков());
								
				Если Не сткОбработчик.ОбработчикНайден Тогда
					
					сшпРаботаСДанными.УстановитьСостояниеСообщения(ИдентификаторСобытия, Перечисления.сшпСтатусыСообщений.ОтсутствуетОбработчик, , , , , Перечисления.сшпТипыИнтеграции.Исходящая);
					
				ИначеЕсли сткОбработчик.Отключен Тогда
					
					сшпРаботаСДанными.УстановитьСостояниеСообщения(ИдентификаторСобытия, Перечисления.сшпСтатусыСообщений.ОбработкаОтменена, , , , , Перечисления.сшпТипыИнтеграции.Исходящая);
					
				Иначе
					
					Задержка = 0;
					ТекстОшибки = "";
					ДопСвойства = Неопределено;	
										
					Объектсобытия = Выборка.Хранилище.Получить();
					
					РезультатОбработки = сшпОбщегоНазначения.СформироватьСтруктуруПакета();
										
					НовыйСтатус = сшпОбщегоНазначения.ПолучитьСтатусСобытия(ИдентификаторСобытия);
					Если Не НовыйСтатус = Перечисления.сшпСтатусыСообщений.ВОбработке Тогда
						Продолжить;
					КонецЕсли;	
										
					СостояниеСообщения = СформироватьИсходящееСообщение(РезультатОбработки, ИдентификаторСообщения, ИдентификаторСобытия, Выборка.ОбъектСобытия, Выборка.методхранения, Объектсобытия, Задержка, сткОбработчик, Выборка.ФорматСообщения, ТекстОшибки, Выборка.ДатаРегистрации, Выборка.ЭтоУдаление, Выборка.СсылкаНаОбъект);
										
					Если СостояниеСообщения = Перечисления.сшпСтатусыСообщений.Обработано Тогда
								
						сшпОбщегоНазначения.УстановитьСвойствоПоиска(Выборка.СсылкаНаОбъект, РезультатОбработки);
												
						СостояниеСообщения = ОтправитьТранспортноеСообщение(ИсходящаяОчередь, РезультатОбработки); 
												
						Если СостояниеСообщения = Перечисления.сшпСтатусыСообщений.НеВалидно Тогда
							
							СостояниеСообщения = Перечисления.сшпСтатусыСообщений.ОшибкаОбработки;
							
						ИначеЕсли СостояниеСообщения = Перечисления.сшпСтатусыСообщений.ОшибкаОбработки Тогда 
							
							ЗапуститьПотокСЗадержкойАссинхронно("сшпTcp.ЗапуститьПотокОбменаТранспортнымиСообщениями", "сшпTcp.ЗапуститьПотокОбменаТранспортнымиСообщениями");
														
							Прервать;
							
						КонецЕсли;
						
					ИначеЕсли Не СостояниеСообщения = Перечисления.сшпСтатусыСообщений.ОтправкаОтменена И
								Не СостояниеСообщения = Перечисления.сшпСтатусыСообщений.ОбработкаОтменена И 
					 			Не СостояниеСообщения = Перечисления.сшпСтатусыСообщений.ОшибкаОбработки И 
								Не СостояниеСообщения = Перечисления.сшпСтатусыСообщений.ОжиданиеОбработки Тогда
						
						СостояниеСообщения = Перечисления.сшпСтатусыСообщений.ОжиданиеОбработки;
						Задержка = 30;
						
					ИначеЕсли СостояниеСообщения = Перечисления.сшпСтатусыСообщений.ОшибкаОбработки Тогда
												
						ТекстОшибки = сшпОбщегоНазначения.ДополнитьТекстОшибки(ТекстОшибки, сткОбработчик, Выборка.СсылкаНаОбъект);					
						ДопСвойства = сшпОбщегоНазначения.ПолучитьИдентификаторОбъектаСобытия(Объектсобытия);
											
					КонецЕсли;
					
					сшпРаботаСДанными.УстановитьСостояниеСообщения(ИдентификаторСобытия, СостояниеСообщения, Задержка, ТекстОшибки, , , Перечисления.сшпТипыИнтеграции.Исходящая, Выборка.ОбъектСобытия, ИдентификаторСообщения, ДопСвойства);
				
				КонецЕсли;
				
			КонецЦикла;
						
		КонецЕсли;
		
	КонецЦикла;
	
	ПрерватьСоединение(ИсходящаяОчередь);
	
КонецПроцедуры

//Функция - сформировать исходящее сообщение
//
//Параметры:
//	РезультатОбработки - Структура - структура пакета, который будет выгружен из 1С
//	Идентификатор - Строка - идентификатор сообщения
//	ИдентификаторСобытия - Строка - идентификатор события
//	ТипОбъекта - Строка - полное имя метаданных, которые вызвали обработку события
//	МетодХранения - Перечисление.сшпМетодХранения - метод хранения объекта
//	ОбъектСобытия - ЛюбаяСсылка, Отбор, ОбъектXDTO - зарегистрированный к выгрузке объект
//	Задержка - Число - Количество секунд задержки перед обработкой
//	СткОбработчик - ФиксированнаяСтруктура - структура обработчика для исходящего сообщения
//	ФорматСообщения - Перечисление.сшпФорматыСообщений - формат исходящего сообщения
//	ТекстОшибки - Строка - возвращаемый текст ошибки
//	ДатаРегистрации - Дата - Дата регистрации сообщения
//	ЭтоУдаление - Булево - Признак удаления
//	СсылкаНаОбъект - ЛюбаяСсылка - Ссылка на объект
//
//Возвращаемое значение:
//	Перечисление.сшпСтатусыСообщений - статус сообщения после обработки
//
Функция СформироватьИсходящееСообщение(РезультатОбработки, Идентификатор, ИдентификаторСобытия, ТипОбъекта,
	МетодХранения, ОбъектСобытия, Задержка, СткОбработчик, ФорматСообщения, ТекстОшибки, ДатаРегистрации, ЭтоУдаление,
	СсылкаНаОбъект)
	
	РезультатОбработки.Id = Идентификатор;
	
	СостояниеСообщения = Перечисления.сшпСтатусыСообщений.Обработано;
	
	ЭтоОшибкаБлокировок = Ложь;
	
	Попытка
		
		ОбъектОбработки = Неопределено;
		
		Если МетодХранения = Перечисления.сшпМетодХранения.ПоСсылке Тогда
			
			Если ТипЗнч(ОбъектСобытия) = Тип("Отбор") Тогда
				
				ТипРегистра = сшпКэшируемыеФункции.ПолучитьТипОбъекта(ТипОбъекта);
				ИмяРегистра = сшпКэшируемыеФункции.ПолучитьИмяОбъекта(ТипОбъекта);
				
				Если ТипРегистра = "РегистрСведений" Тогда
					
					ОбъектОбработки = РегистрыСведений[ИмяРегистра].СоздатьНаборЗаписей();	
					
				ИначеЕсли ТипРегистра = "РегистрНакопления" Тогда
					
					ОбъектОбработки = РегистрыНакопления[ИмяРегистра].СоздатьНаборЗаписей();
					
				ИначеЕсли ТипРегистра = "РегистрБухгалтерии" Тогда
					
					ОбъектОбработки = РегистрыБухгалтерии[ИмяРегистра].СоздатьНаборЗаписей();
					
				ИначеЕсли ТипРегистра = "РегистрРасчета" Тогда
					
					ОбъектОбработки = РегистрыРасчета[ИмяРегистра].СоздатьНаборЗаписей();
					
				Иначе
					
					ВызватьИсключение "Тип: " + ТипРегистра + " не поддерживается текущей версией подсистемы ESB";
					
				КонецЕсли;
				
				Для Каждого ЭлементОтбор Из ОбъектСобытия Цикл
					ЗаполнитьЗначенияСвойств(ОбъектОбработки.Отбор[элементОтбор.Имя], ЭлементОтбор);
				КонецЦикла;
				
				Попытка
					
					ОбъектОбработки.Прочитать();
						
				Исключение
					
					ЭтоОшибкаБлокировок = сшпОбщегоНазначения.ЭтоОшибкаКонфликтаБлокировок(ОписаниеОшибки());
					
					ВызватьИсключение;
					
				КонецПопытки;
	
			Иначе
				
				ОбъектОбработки = ОбъектСобытия;
				
				//Проверка акутальности данных в объектном кеше для объектов
				Если сшпКэшируемыеФункции.ПроверятьАктуальностьОбъектногоКеша() И ЗначениеЗаполнено(СсылкаНаОбъект) И
					Не сшпРаботаСДанными.ОбъектныйКешАктуален(СсылкаНаОбъект, ТипОбъекта) Тогда 
					СостояниеСообщения = Перечисления.сшпСтатусыСообщений.ОжиданиеОбработки;
					Задержка = сшпКэшируемыеФункции.ВремяОжиданияПриНеактуальномОбъектномКеше();
					ТекстОшибки = "Обработка отложена из-за неактуальности версий в объектном кеше";
					
					Возврат СостояниеСообщения;

				КонецЕсли;
				
			КонецЕсли;
			
		Иначе	
			
			ОбъектОбработки = сшпОбщегоНазначения.ДесериализоватьОбъект(ФорматСообщения, ОбъектСобытия);
			
		КонецЕсли;
		
		сшпОбщегоНазначения.ВыполнитьКодИсходящегоОбработчика(сткОбработчик.ПроцедураОбработки, РезультатОбработки,
			Идентификатор, ИдентификаторСобытия, ТипОбъекта, МетодХранения, ОбъектСобытия, Задержка, СткОбработчик,
			ФорматСообщения, ТекстОшибки, ДатаРегистрации, ЭтоУдаление, СсылкаНаОбъект, ОбъектОбработки,
			СостояниеСообщения);
	
	Исключение
		
		Если ЭтоОшибкаБлокировок тогда

			ЗаписьЖурналаРегистрации("Datareon. Получение объекта события", УровеньЖурналаРегистрации.Предупреждение, ,
				ИдентификаторСобытия, "Ошибка конфликта блокировок при чтении набора записей регистра. Обработка отложена.");
	
			СостояниеСообщения = Перечисления.сшпСтатусыСообщений.ОжиданиеОбработки;
			Задержка = 10;
			
		Иначе	

			ТекстОшибки = сшпОбщегоНазначения.ПолучитьТекстОшибкиОбработчика(ИнформацияОбОшибке());
			
			СостояниеСообщения = Перечисления.сшпСтатусыСообщений.ОшибкаОбработки;
			
		КонецЕсли;
		
	КонецПопытки;
	
	Возврат СостояниеСообщения;
	
КонецФункции

//Функция - Отправить транспортное сообщение
//
//Параметры:
//	Очередь - ВнешняяКомпонента - экземпляр внешней компоненты текущей очереди
//	СтруктураСообщения - Структура - структура передаваемого сообщения
//
//Возвращаемое значение:
//	Перечисление.сшпСтатусыСообщений - статус сообщения после обработки
//
Функция ОтправитьТранспортноеСообщение(Соединение, СтруктураСообщения) Экспорт
		
	Попытка
		
		xmlПакет = сшпОбщегоНазначения.СформироватьСообщениеESB_HTTP(ФабрикаXDTO, СтруктураСообщения);
			
	Исключение
		
		ТекстОшибки = "Не удалось сериализовать исходящее сообщение " + СтруктураСообщения.Id + " по причине:"
			+ Символы.ПС + ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());	
		ЗаписьЖурналаРегистрации("Datareon. Обработка очереди исходящих сообщений", УровеньЖурналаРегистрации.Ошибка, , , ТекстОшибки);		
		
		ЗарегистрироватьОшибку(Соединение, ТекстОшибки); 
		
		Возврат Перечисления.сшпСтатусыСообщений.НеВалидно;
		
	КонецПопытки;
	
	Попытка

		ОтправитьСообщение(Соединение, xmlПакет);
		
	Исключение
		
		ТекстОшибки = "Не удалось отправить исходящее сообщение " + СтруктураСообщения.Id + " по причине:"
			+ Символы.ПС + ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());	
		ЗаписьЖурналаРегистрации("Datareon. Обработка очереди исходящих сообщений", УровеньЖурналаРегистрации.Предупреждение, , , ТекстОшибки);
		
		Возврат Перечисления.сшпСтатусыСообщений.ОшибкаОбработки;
		
	КонецПопытки;
	
	Возврат Перечисления.сшпСтатусыСообщений.Отправлено;
	
КонецФункции

//Процедура - Отправить сообщение
//
//Параметры:
//	Соединение - ВнешняяКомпонента - экземпляр внешней компоненты
//	xmlПакет - ЗаписьXML - передаваемый пакет
//
Процедура ОтправитьСообщение(Соединение, xmlПакет) Экспорт
	
	Соединение.CallAsFunc("SendTcpMessage", xmlПакет);
	
КонецПроцедуры

//Функция - Отправить сообщение об ошибке
//
//Параметры:
//	Очередь - ВнешняяКомпонента - экземпляр внешней компоненты
//	Класс - Строка - класс сообщения
//	Описание - Строка - тело пакета
//	Свойства - Структура - дополнительные свойства
//
//Возвращаемое значение:
//	Строка - текст ошибки
//
Функция ОтправитьСообщениеОбОшибке(Очередь, Класс, Описание, Свойства) Экспорт
	
	Попытка
		
		Сообщение = сшпОбщегоНазначения.СформироватьСтруктуруПакета("TER", Класс, Описание);
		Сообщение.Properties = Свойства;
		
		xmlПакет = сшпОбщегоНазначения.СформироватьСообщениеESB_HTTP(ФабрикаXDTO, Сообщение);
		
	Исключение
		
		ТекстОшибки = "Не удалось сериализовать сообщение класса TER по причине:"
			+ Символы.ПС + ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());	
		ЗаписьЖурналаРегистрации("Datareon. Обработка очереди исходящих сообщений", УровеньЖурналаРегистрации.Ошибка, , , ТекстОшибки);
		
		ЗарегистрироватьОшибку(Очередь, ТекстОшибки);
		
		Возврат "";
		
	КонецПопытки;
	
	Попытка
		
		ОтправитьСообщение(Очередь, xmlПакет);
		
	Исключение
		
		ТекстОшибки = "Не удалось отправить сообщение класса TER по причине:"
			+ Символы.ПС + ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());	
			
		ЗаписьЖурналаРегистрации("Datareon. Обработка очереди сообщений", УровеньЖурналаРегистрации.Предупреждение, , , ТекстОшибки);
		
		Возврат ТекстОшибки;
		
	КонецПопытки;
	
	Возврат "";
	
КонецФункции

// Функция - Отправить сообщение без очереди
//
// Параметры:
//  Сообщение - Структура - Структура описывающая состав отправляемого сообщения.
// 
// Возвращаемое значение:
//  Булево - Признак успешности отправки сообщения на адаптер.
//
Функция ОтправитьСообщениеБезОчереди(Сообщение) Экспорт
	
	Возврат ОтправитьСообщениеБезОчередиВнутренний(Сообщение, 0);
	
КонецФункции

// Функция - Отправить сообщение без очереди служебным каналом
//
// Параметры:
//  Сообщение - Структура - Структура описывающая состав отправляемого сообщения.
// 
// Возвращаемое значение:
//  Булево - Признак успешности отправки сообщения на адаптер.
//
Функция ОтправитьСообщениеБезОчередиСлужебный(Сообщение) Экспорт
	
	Возврат ОтправитьСообщениеБезОчередиВнутренний(Сообщение, 1);
	
КонецФункции

// Функция - Отправить сообщение без очереди
//
// Параметры:
//  Сообщение - Структура - Структура описывающая состав отправляемого сообщения.
//  ИдентификаторКанала - Число - Идентифкатор канала
// 
// Возвращаемое значение:
//  Булево - Признак успешности отправки сообщения на адаптер.
//
Функция ОтправитьСообщениеБезОчередиВнутренний(Сообщение, ИдентификаторКанала)
	
	ОтправкаРезультат = Истина;
	
	Попытка
		
		ИсходящаяОчередь = Обработки.сшпВызовыКомпоненты.Создать();
		ИсходящаяОчередь.ИнициализироватьКомпоненту();
		
		СтруктураСоединения = ПолучитьСтруктуруСоединения();
		СтруктураСоединения.Компонента = ИсходящаяОчередь;
		СтруктураСоединения.Сервисный = ИдентификаторКанала;
		СтруктураСоединения.Режим = 1;
		
		Если УстановитьСоединение(СтруктураСоединения) Тогда
		
			ОтправитьТранспортноеСообщение(ИсходящаяОчередь, Сообщение);
			
			ПрерватьСоединение(ИсходящаяОчередь);
			
		КонецЕсли;
		
	Исключение
		
		ИнформацияОбОшибке = ИнформацияОбОшибке();
		ЗаписьЖурналаРегистрации("Datareon. Помещение сообщения в очередь на отправку", УровеньЖурналаРегистрации.Ошибка, , , ПодробноеПредставлениеОшибки(ИнформацияОбОшибке));
		ОтправкаРезультат = Ложь;
	
	КонецПопытки;
	
	Возврат ОтправкаРезультат;

КонецФункции

#КонецОбласти

#Область ВспомогательныеМетоды

//Функция - Проверить разрешение на работу
//
//Параметры:
//	ВерсияПараметровПодсистемы - УникальныйИдентификатор - версия параметров подсистемы
//	ТипОчереди - Перечисление.сшпТипыОчередей - Тип очереди
//	ИндексПотока - Число - Индекс потока
//
//Возвращаемое значение:
//  Булево - результат проверки
//
Функция ПроверитьРазрешениеНаРаботу(ВерсияПараметровПодсистемы, ТипОчереди, ИндексПотока = 0)
		
	Если КонфигурацияБазыДанныхИзмененаДинамически() Тогда
		
		Возврат Ложь;
		
	КонецЕсли;
		
	Если сшпФункциональныеОпции.ОтключитьСоединение() Тогда
		
		Возврат Ложь;
		
	КонецЕсли;
		
	Если сшпОбщегоНазначения.ПараметрыПодсистемыОбновлены(ВерсияПараметровПодсистемы) Тогда 
		
		Если Константы.сшпИДАдаптера.Получить() <> сшпРаботаСКонстантами.ПолучитьИдАдаптера() Тогда 
			
			Возврат Ложь;
			
		КонецЕсли;
		
		ОбновитьПовторноИспользуемыеЗначения();
		
		Если Не сшпФункциональныеОпции.ИспользоватьСШП() Тогда
			
			Возврат Ложь;
			
		КонецЕсли;
		
		Если сшпФункциональныеОпции.ТипИспользуемогоКоннектораESB() <> Перечисления.сшпТипыКоннекторовESB.Tcp Тогда 
			
			Возврат Ложь;
			
		КонецЕсли;
		
		Если сшпФункциональныеОпции.ОтключитьПотоки() И Не ТипОчереди = Перечисления.сшпТипыОчередей.Системная Тогда 
			
			Возврат Ложь;
			
		КонецЕсли;
		
	КонецЕсли;
	
	Если ТипОчереди = Перечисления.сшпТипыОчередей.Входящая И 
		сшпРаботаСКонстантами.ПолучитьЗначениеКонстанты("сшпМаксимальноеКоличествоПотоковОбработкиВходящих") < ИндексПотока Тогда
			
		Возврат Ложь;
			
	КонецЕсли;
		
	Если ТипОчереди = Перечисления.сшпТипыОчередей.Исходящая И 
		сшпРаботаСКонстантами.ПолучитьЗначениеКонстанты("сшпМаксимальноеКоличествоПотоковОбработкиИсходящих") < ИндексПотока Тогда
			
		Возврат Ложь;
			
	КонецЕсли;
	
	Возврат Истина;
	
КонецФункции	

//Функция - Получить строку соединения с ИБ по структуре адреса, формируемой функцией ПолучитьСтруктуруАдресаИБ
//
//Параметры:
//	АдресИБ - Структура - ключи Адрес, Порт, ИмяБазы
//
//Возвращаемое значение:
//  Строка - строка соединения с информационной базой
//
Функция ПолучитьСтрокуСоединенияСИнформационнойБазойПоСтруктуреАдреса(АдресИБ)
	Возврат "Srvr=""" + АдресИБ.Адрес + ":" + XMLСтрока(АдресИБ.Порт) + """;Ref=""" + АдресИБ.ИмяБазы + """;"	
КонецФункции	

#КонецОбласти

#Область РаботаСФункциями

Функция ВыполнитьФункцию(ИмяФункции, dt_Параметр1 = Неопределено, dt_Параметр2 = Неопределено,
	dt_Параметр3 = Неопределено, dt_Параметр4 = Неопределено, dt_Параметр5 = Неопределено, dt_Параметр6 = Неопределено,
	dt_Параметр7 = Неопределено, dt_Параметр8 = Неопределено, dt_Параметр9 = Неопределено, dt_Параметр10 = Неопределено)

	Возврат сшпОбщегоНазначения.ВыполнитьФункцию(ИмяФункции, dt_Параметр1, dt_Параметр2, dt_Параметр3, dt_Параметр4,
		dt_Параметр5, dt_Параметр6, dt_Параметр7, dt_Параметр8, dt_Параметр9, dt_Параметр10);

КонецФункции

#КонецОбласти
