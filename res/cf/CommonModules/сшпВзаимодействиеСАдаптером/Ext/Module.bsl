
#Область ПрограммныйИнтерфейс

// Функция - Отправить сообщение без очереди
//
// Параметры:
//  Сообщение - Структура - Структура описывающая состав отправляемого сообщения. Способ обработки зависит от типа коннектора адаптера.
//  СостояниеСообщения - Перечисление.сшпСтатусыСообщений - Статус сообщения.
// 
// Возвращаемое значение:
//  Булево - Признак успешности отправки сообщения на адаптер.
//
Функция ОтправитьСообщениеБезОчереди(Сообщение, СостояниеСообщения = Неопределено) Экспорт
	
	отправкаРезультат = Истина;
		
	Попытка
		
		сшпРаботаСДанными.УстановитьСостояниеСообщения(Сообщение.Id, Перечисления.сшпСтатусыСообщений.Отправлено, , , , , Перечисления.сшпТипыИнтеграции.Исходящая);
		
		Коннектор = сшпВзаимодействиеСАдаптером.ПолучитьКоннектор();
		
		Если Коннектор = Неопределено Тогда
			
			Возврат Ложь;
			
		КонецЕсли;
		
		Если Не ПолучитьФункциональнуюОпцию("сшпИспользоватьСШП") Или ПолучитьФункциональнуюОпцию("сшпОтключитьПотоки") Тогда
			
			Возврат Ложь;
			
		КонецЕсли;
		
		сшпОбслуживаниеОчередей.ОтправитьСообщение(Коннектор, Сообщение);
				
		Если Не СостояниеСообщения = Неопределено Тогда
			СостояниеСообщения = Перечисления.сшпСтатусыСообщений.Отправлено;
		КонецЕсли;
		
	Исключение
		
		отправкаРезультат = Ложь;
		ИнформацияОбОшибке = ИнформацияОбОшибке();
		ЗаписьЖурналаРегистрации("Datareon. Обработка очереди отправляемых сообщений", УровеньЖурналаРегистрации.Ошибка, , , ПодробноеПредставлениеОшибки(ИнформацияОбОшибке));
		
	КонецПопытки;
	
	Возврат отправкаРезультат;
	
КонецФункции

// Функция - Отправить системное сообщение без очереди
//
// Параметры:
//  Сообщение - Структура - Структура описывающая состав отправляемого сообщения. Способ обработки зависит от типа коннектора адаптера.
// 
// Возвращаемое значение:
//  Булево - Признак успешности отправки сообщения на адаптер.
//
Функция ОтправитьСистемноеСообщениеБезОчереди(Сообщение) Экспорт
	
	Если сшпФункциональныеОпции.ТипИспользуемогоКоннектораESB() = Перечисления.сшпТипыКоннекторовESB.Pipe Тогда 
		
		сшпPipe.УстановитьСоединениеИОтправитьСлужебноеСообщение(Сообщение);	
	
	ИначеЕсли сшпФункциональныеОпции.ТипИспользуемогоКоннектораESB() = Перечисления.сшпТипыКоннекторовESB.Tcp Тогда 
		
		сшпTcp.УстановитьСоединениеИОтправитьСлужебноеСообщение(Сообщение);
		
	Иначе
	
		Коннектор = сшпВзаимодействиеСАдаптером.ПолучитьКоннектор();
		Если Коннектор = Неопределено Тогда
		
			Возврат Ложь;
				
		КонецЕсли;
		
		Если Не ПолучитьФункциональнуюОпцию("сшпИспользоватьСШП") Тогда
				
			Возврат Ложь;
			
		КонецЕсли;
		
		Попытка		
			
			ТекИдентификатор = Новый УникальныйИдентификатор;
			СистемноеСообщение = Сообщение;
			СистемноеСообщение.Id = ТекИдентификатор;
			
			сшпОбслуживаниеОчередей.ОтправитьСообщение(Коннектор, Сообщение, Ложь);
		
		Исключение
					
			ИнформацияОбОшибке = ИнформацияОбОшибке();
			ЗаписьЖурналаРегистрации("Datareon. Обработка очереди отправляемых сообщений", УровеньЖурналаРегистрации.Ошибка, , ТекИдентификатор, ПодробноеПредставлениеОшибки(ИнформацияОбОшибке));
			
			Возврат Ложь;
			
		КонецПопытки;
	
		Коннектор = Неопределено;
		
	КонецЕсли;
	
	Возврат Истина;
	
КонецФункции

// Функция - Получение сообщения
//
// Параметры:
//  Формат - Перечисление.сшпФорматыСообщений - формат поступившего сообщения
//  xdtoПакет - ОбъектXDTO.Message1C - сообщение в формате ОбъектXDTO
// 
// Возвращаемое значение:
//  Булево - Признак удачной обработки полученного сообщения. 
//
Функция ПолучениеСообщения(Формат, xdtoПакет) Экспорт
	
	КодОтвета = 200;
	ФорматОберткиСообщения = сшпКэшируемыеФункции.ФорматСообщенийПоУмолчанию();
	
	Если сшпКэшируемыеФункции.ЭтоСистемноеСообщение(xdtoПакет.Type) Тогда
		
		Если ПолучитьФункциональнуюОпцию("сшпИспользоватьСШП") Тогда 
			
			xmlПакет = сшпОбщегоНазначения.ЗаписатьОбъектВПоток(ФорматОберткиСообщения, xdtoПакет);
			сшпРаботаСДанными.ОбработатьВходящееСлужебноеСообщениеБезОчереди(xdtoПакет.Id, xmlПакет, xdtoПакет.Type, ФорматОберткиСообщения);
			
		КонецЕсли;
	
	ИначеЕсли сшпКэшируемыеФункции.ЭтоКомандноеСообщение(xdtoПакет.Type) Тогда
		
		Если xdtoПакет.Type = "CSM" Тогда
			
			сшпОбщегоНазначения.ЗапуститьОбработчикОчереди("УправлениеПуломОбработчиков");
			сшпСистемныеСообщения.ПолучитьСостояниеОбработки();
		
		ИначеЕсли xdtoПакет.Type = "CSA" Тогда
			
			сткПараметры = сшпОбщегоНазначения.ПолучитьПараметрыСообщенияСтруктурой(xdtoПакет);
			сшпОбновлениеВерсииКонфигурации.ПроверитьИспользованиеПараметров(сткПараметры);
			сшпРаботаСДанными.УстановитьПараметрыАдаптера(сткПараметры);
		
		ИначеЕсли xdtoПакет.Type = "GCM" Тогда
			
			xmlПакет = сшпОбщегоНазначения.ЗаписатьОбъектВПоток(ФорматОберткиСообщения, xdtoПакет);
			
			мсвПараметры = Новый Массив;
			мсвПараметры.Добавить(xdtoПакет.Id);
			мсвПараметры.Добавить(ФорматОберткиСообщения);
			мсвПараметры.Добавить(xmlПакет);
			
			ФоновыеЗадания.Выполнить("сшпОбслуживаниеОчередей.ВыполнитьВнешнююКоманду", мсвПараметры, , "сшпОбслуживаниеОчередей.ВыполнитьВнешнююКоманду");
		
		ИначеЕсли xdtoПакет.Type = "SUS" Тогда
			
			сткПараметры = сшпОбщегоНазначения.ПолучитьПараметрыСообщенияСтруктурой(xdtoПакет);
			
			мсвПараметры = Новый Массив;
			мсвПараметры.Добавить(xdtoПакет.Id);
			мсвПараметры.Добавить(сткПараметры);
			
			ФоновыеЗадания.Выполнить("сшпОбслуживаниеОчередей.УстановитьПараметрыПользователя", мсвПараметры, , "сшпОбслуживаниеОчередей.УстановитьПараметрыПользователя");
		
		КонецЕсли;
		
		Если Ложь Тогда 
			
			xmlПакет = сшпОбщегоНазначения.ЗаписатьОбъектВПоток(ФорматОберткиСообщения, xdtoПакет);
			сшпРаботаСДанными.ОбработатьВходящееСлужебноеСообщениеБезОчереди(xdtoПакет.Id, xmlПакет, xdtoПакет.Type, ФорматОберткиСообщения);
		
		КонецЕсли;
	
	ИначеЕсли сшпКэшируемыеФункции.ЭтоТранспортноеСообщение(xdtoПакет.Type) Тогда
			
		КоличествоПотоковМаксимум = сшпРаботаСКонстантами.МаксимальноеКоличествоПотоковОбработкиВходящих();
		КоличествоПотоковЗапущено = сшпОбщегоНазначения.ПолучитьКоличествоПотоков("Наименование", "ОбработатьВходящееСообщениеБезОчереди");
		
		КоличествоПопыток = 250;
		
		Пока КоличествоПотоковЗапущено >= КоличествоПотоковМаксимум Цикл
						
			Если КоличествоПопыток <= 0 Тогда 
				
				//Отправляем статус занято
				ПакетПотокиЗаняты = сшпОбщегоНазначения.СформироватьСтруктуруПакета("SSM","Esb-1CIsBusy");
				сшпВзаимодействиеСАдаптером.ОтправитьСистемноеСообщениеБезОчереди(ПакетПотокиЗаняты); 						
				
				//Запустить поток контроля
				сшпОбщегоНазначения.ЗапуститьОбработчикОчереди("КонтрольВходящихПотоков", "сшпВзаимодействиеСАдаптером");
				
				Возврат -1;
				
			КонецЕсли;
						
			КоличествоПотоковЗапущено = сшпОбщегоНазначения.ПолучитьКоличествоПотоков("Наименование", "ОбработатьВходящееСообщениеБезОчереди");
			
			сшпОбщегоНазначения.ОжиданиеМСек(100); 
			
			КоличествоПопыток = КоличествоПопыток - 1;
			
			
		КонецЦикла;
		
		xmlПакет = сшпОбщегоНазначения.ЗаписатьОбъектВПоток(ФорматОберткиСообщения, xdtoПакет);
		
		мсвПараметры = Новый Массив;
		мсвПараметры.Добавить(Формат);
		мсвПараметры.Добавить(xmlПакет);
		
		ФоновыеЗадания.Выполнить("сшпРаботаСДанными.ОбработатьВходящееСообщениеБезОчереди", мсвПараметры, , "ОбработатьВходящееСообщениеБезОчереди");
		
	Иначе
		
		КлассСообщения = ?(ТипЗнч(xdtoПакет.ClassId) = Тип("Строка"), xdtoПакет.ClassId, "");
		сшпСистемныеСообщения.ОтправитьСостояниеСообщения(Строка(xdtoПакет.Id), Перечисления.сшпСтатусыСообщений.НеВалидно, "Получен неизвестный тип сообщения " + Строка(xdtoПакет.Type) + ", сообщение с данными должно иметь тип DTP", 0, Перечисления.сшпТипыИнтеграции.Входящая, КлассСообщения);
		
		КодОтвета = 200; // Приходит неизвестный тип пакета. Вероятно требуется обновление обработчика.
	
	КонецЕсли;	
	
	Возврат КодОтвета;

КонецФункции	

// Процедура - Контроль входящих потоков
//
Процедура КонтрольВходящихПотоков() Экспорт
	
	//Ждем 25 минут, и выключаемся
	Таймаут = 1560;
	СтартПотока = ТекущаяУниверсальнаяДата();
	Таймер = ТекущаяУниверсальнаяДата() - СтартПотока;
	КоличествоПотоковМаксимум = сшпРаботаСКонстантами.МаксимальноеКоличествоПотоковОбработкиВходящих();
		
	Пока Таймер < Таймаут Цикл
		
		КоличествоПотоковЗапущено = сшпОбщегоНазначения.ПолучитьКоличествоПотоков("Наименование", "ОбработатьВходящееСообщениеБезОчереди");
		Таймер = ТекущаяУниверсальнаяДата() - СтартПотока;
		
		Если КоличествоПотоковЗапущено < КоличествоПотоковМаксимум Тогда
			
			ПакетПотокиСвободны = сшпОбщегоНазначения.СформироватьСтруктуруПакета("SSM","Esb-1CIsFree");	
			сшпВзаимодействиеСАдаптером.ОтправитьСистемноеСообщениеБезОчереди(ПакетПотокиСвободны); 
			
			Прервать; 	
			
		КонецЕсли;
		
		сшпОбщегоНазначения.Ожидание(1);
		
	КонецЦикла;
	
КонецПроцедуры

// Процедура - Отправить сообщение на адаптер
//
// Параметры:
//  Коннектор - WSПрокси, HTTPСоединение - Объект соединения с web-сервисом. 
//  Сообщение - Структура - Структура с данными отправляемого сообщения
//  ИзменятьСтатус - Булево - Вызов метода УстановитьСостояниеСообщения
//
Процедура ОтправитьСообщениеНаАдаптер(Коннектор, Сообщение, ИзменятьСтатус = Истина) Экспорт
	
	отправкаРезультат = Истина;
	текТипКоннектора = сшпФункциональныеОпции.ТипИспользуемогоКоннектораESB();
	
	Если текТипКоннектора = Перечисления.сшпТипыКоннекторовESB.REST тогда
		
		отправкаРезультат = сшпHTTPСервис.ОтправитьСообщение(Коннектор, Сообщение);
	
	ИначеЕсли текТипКоннектора = Перечисления.сшпТипыКоннекторовESB.SOAP тогда
		
		отправкаРезультат = сшпSOAPСервис.ОтправитьСообщение(Коннектор, Сообщение);
	
	КонецЕсли;
	
	Если ТипЗнч(Сообщение) = Тип("Массив") Тогда 
		
		МассивСообщений = Сообщение;
	
	Иначе
		
		МассивСообщений = Новый Массив;
		МассивСообщений.Добавить(Сообщение);
	
	КонецЕсли;
	
	Если ИзменятьСтатус Тогда
	
		Для Каждого ОдиночноеСообщение Из МассивСообщений Цикл 
			
			Если Не отправкаРезультат Тогда
							
				сшпРаботаСДанными.УстановитьСостояниеСообщения(ОдиночноеСообщение.Id, Перечисления.сшпСтатусыСообщений.ОжиданиеОбработки, 30, , , , Перечисления.сшпТипыИнтеграции.Исходящая);
			
			КонецЕсли;	
		
		КонецЦикла;
		
	КонецЕсли;

КонецПроцедуры

// Функция - Получить коннектор
// 
// Возвращаемое значение:
//  WSПрокси, HTTPСоединение - объект соединения с web-сервисом.
//
Функция ПолучитьКоннектор() Экспорт
	
	коннектор = Неопределено;
 	типКоннектора = сшпФункциональныеОпции.ТипИспользуемогоКоннектораESB();
	
	Если типКоннектора = Перечисления.сшпТипыКоннекторовESB.REST Тогда
		
		коннектор = ПолучитьHTTPСоединение(сшпФункциональныеОпции.АдресАдаптераESB());
	
	ИначеЕсли типКоннектора = Перечисления.сшпТипыКоннекторовESB.SOAP Тогда
		
		коннектор = ПолучитьWSПрокси(сшпФункциональныеОпции.АдресАдаптераESB());
	
	Иначе 
		
		ЗаписьЖурналаРегистрации("Datareon. Взаимодействие с адаптером", УровеньЖурналаРегистрации.Ошибка, , , "Не определен тип коннектора");
	
	КонецЕсли;		
	
	Возврат коннектор;

КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

// Функция - Получить WSПрокси
//
// Параметры:
//  Адрес - Строка - строка с адресом web-сервиса. 
// 
// Возвращаемое значение:
// WSПрокси - сформированный объект WSПрокси с по заданному адресу web-сервиса.
//
Функция ПолучитьWSПрокси(Адрес)
	
	результатВозврат = Неопределено;
	
	Попытка
		
		soapСервис = WSСсылки.ESBAdapter.ПолучитьWSОпределения().Сервисы[0];
		результатВозврат =  WSСсылки.ESBAdapter.СоздатьWSПрокси("http://esb.axelot.ru", soapСервис.Имя, soapСервис.ТочкиПодключения[0].Имя, , 120, ЗащищенноеСоединение(Адрес), Адрес);
	
	Исключение
		
		ЗаписьЖурналаРегистрации("Datareon. Взаимодействие с адаптером", УровеньЖурналаРегистрации.Ошибка, , , "Не удалось создать подключение к адаптеру по причине: " + ОписаниеОшибки());
	
	КонецПопытки;
	
	Возврат результатВозврат;

КонецФункции

// Функция - Получить HTTPСоединение
//
// Параметры:
//  адрес - Строка - строка с адресом http-сервиса.
// 
// Возвращаемое значение:
// HTTPСоединение - сформированный объект HTTPСоединение с по заданному адресу http-сервиса.
//
Функция ПолучитьHTTPСоединение(Адрес)
	
	значЗащищенноеСоединение = ЗащищенноеСоединение(Адрес);
	
	Если Лев(НРег(Адрес), 5) = "https" Тогда
		Адрес = СтрЗаменить(Адрес, "https://", "");
	КонецЕсли;
	
	Возврат Новый HTTPСоединение(Адрес, , , , , , значЗащищенноеСоединение);

КонецФункции

//Функция - защищенное соединение
//
// Параметры:
//  адрес - Строка - строка с адресом сервиса.
// 
// Возвращаемое значение:
// ЗащищенноеСоединениеOpenSSL - сформированный объект ЗащищенноеСоединениеOpenSSL.
//
Функция ЗащищенноеСоединение(Адрес)
	
	Если Лев(НРег(Адрес), 5) = "https" Тогда
		
		Возврат Новый ЗащищенноеСоединениеOpenSSL;
		
	Иначе
		
		Возврат Неопределено;
		
	КонецЕсли;
		
КонецФункции

#КонецОбласти

#Область ЛогированиеВебСервисы
Процедура ЗарегистрироватьОшибку(ТекстСообщения) Экспорт
	
	сшпСистемныеСообщения.ОтправитьСлужебныйЛог(3, ТекстСообщения);
	
КонецПроцедуры

Процедура ЗарегистрироватьПредупреждение(ТекстСообщения) Экспорт
	
	сшпСистемныеСообщения.ОтправитьСлужебныйЛог(2, ТекстСообщения);
	
КонецПроцедуры

Процедура ЗарегистрироватьИнформационноеСообщение(ТекстСообщения) Экспорт
	
	сшпСистемныеСообщения.ОтправитьСлужебныйЛог(1, ТекстСообщения);
	
КонецПроцедуры

Процедура ЗарегистрироватьОтладочноеСообщение(ТекстСообщения) Экспорт
	
	сшпСистемныеСообщения.ОтправитьСлужебныйЛог(0, ТекстСообщения);
	
КонецПроцедуры
#КонецОбласти
